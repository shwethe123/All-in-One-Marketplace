'use strict';

var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined") return require.apply(this, arguments);
  throw Error('Dynamic require of "' + x + '" is not supported');
});

// ../core/src/types.ts
var BlinkError = class extends Error {
  constructor(message, code, status, details) {
    super(message);
    this.code = code;
    this.status = status;
    this.details = details;
    this.name = "BlinkError";
  }
};
var BlinkAuthError = class extends BlinkError {
  constructor(message, details) {
    super(message, "AUTH_ERROR", 401, details);
    this.name = "BlinkAuthError";
  }
};
var BlinkNetworkError = class extends BlinkError {
  constructor(message, status, details) {
    super(message, "NETWORK_ERROR", status, details);
    this.name = "BlinkNetworkError";
  }
};
var BlinkValidationError = class extends BlinkError {
  constructor(message, details) {
    super(message, "VALIDATION_ERROR", 400, details);
    this.name = "BlinkValidationError";
  }
};
var BlinkStorageError = class extends BlinkError {
  constructor(message, status, details) {
    super(message, "STORAGE_ERROR", status, details);
    this.name = "BlinkStorageError";
  }
};
var BlinkAIError = class extends BlinkError {
  constructor(message, status, details) {
    super(message, "AI_ERROR", status, details);
    this.name = "BlinkAIError";
  }
};
var BlinkDataError = class extends BlinkError {
  constructor(message, status, details) {
    super(message, "DATA_ERROR", status, details);
    this.name = "BlinkDataError";
  }
};
var BlinkRealtimeError = class extends BlinkError {
  constructor(message, status, details) {
    super(message, "REALTIME_ERROR", status, details);
    this.name = "BlinkRealtimeError";
  }
};
var BlinkNotificationsError = class extends BlinkError {
  constructor(message, status, details) {
    super(message, "NOTIFICATIONS_ERROR", status, details);
    this.name = "BlinkNotificationsError";
  }
};

// ../core/src/query-builder.ts
function camelToSnake(str) {
  return str.replace(/[A-Z]/g, (letter) => `_${letter.toLowerCase()}`);
}
function convertFilterKeysToSnakeCase(condition) {
  if (!condition) return condition;
  if ("AND" in condition) {
    return {
      AND: condition.AND?.map(convertFilterKeysToSnakeCase)
    };
  }
  if ("OR" in condition) {
    return {
      OR: condition.OR?.map(convertFilterKeysToSnakeCase)
    };
  }
  const converted = {};
  for (const [field, value] of Object.entries(condition)) {
    const snakeField = camelToSnake(field);
    converted[snakeField] = value;
  }
  return converted;
}
function buildFilterQuery(condition) {
  if (!condition) return "";
  if ("AND" in condition) {
    const andConditions = condition.AND?.map(buildFilterQuery).filter(Boolean) || [];
    return andConditions.length > 0 ? `and=(${andConditions.join(",")})` : "";
  }
  if ("OR" in condition) {
    const orConditions = condition.OR?.map(buildFilterQuery).filter(Boolean) || [];
    return orConditions.length > 0 ? `or=(${orConditions.join(",")})` : "";
  }
  const params = [];
  for (const [field, value] of Object.entries(condition)) {
    if (value === void 0 || value === null) continue;
    if (typeof value === "object" && !Array.isArray(value)) {
      for (const [operator, operatorValue] of Object.entries(value)) {
        const param = buildOperatorQuery(field, operator, operatorValue);
        if (param) params.push(param);
      }
    } else {
      params.push(`${field}=eq.${encodeQueryValue(value)}`);
    }
  }
  return params.join("&");
}
function buildOperatorQuery(field, operator, value) {
  switch (operator) {
    case "eq":
      return `${field}=eq.${encodeQueryValue(value)}`;
    case "neq":
      return `${field}=neq.${encodeQueryValue(value)}`;
    case "gt":
      return `${field}=gt.${encodeQueryValue(value)}`;
    case "gte":
      return `${field}=gte.${encodeQueryValue(value)}`;
    case "lt":
      return `${field}=lt.${encodeQueryValue(value)}`;
    case "lte":
      return `${field}=lte.${encodeQueryValue(value)}`;
    case "like":
      return `${field}=like.${encodeQueryValue(value)}`;
    case "ilike":
      return `${field}=ilike.${encodeQueryValue(value)}`;
    case "is":
      return `${field}=is.${value === null ? "null" : encodeQueryValue(value)}`;
    case "not":
      return `${field}=not.${encodeQueryValue(value)}`;
    case "in":
      if (Array.isArray(value)) {
        const values = value.map(encodeQueryValue).join(",");
        return `${field}=in.(${values})`;
      }
      return "";
    case "not_in":
      if (Array.isArray(value)) {
        const values = value.map(encodeQueryValue).join(",");
        return `${field}=not.in.(${values})`;
      }
      return "";
    default:
      return "";
  }
}
function encodeQueryValue(value) {
  if (value === null) return "null";
  if (typeof value === "boolean") {
    return value ? "1" : "0";
  }
  if (typeof value === "number") return value.toString();
  return encodeURIComponent(String(value));
}
function buildQuery(options = {}) {
  const params = {};
  if (options.select && options.select.length > 0) {
    const snakeFields = options.select.map(camelToSnake);
    params.select = snakeFields.join(",");
  } else {
    params.select = "*";
  }
  if (options.where) {
    const convertedWhere = convertFilterKeysToSnakeCase(options.where);
    const filterQuery = buildFilterQuery(convertedWhere);
    if (filterQuery) {
      const filterParams = filterQuery.split("&");
      for (const param of filterParams) {
        const [key, value] = param.split("=", 2);
        if (key && value) {
          params[key] = value;
        }
      }
    }
  }
  if (options.orderBy) {
    if (typeof options.orderBy === "string") {
      params.order = options.orderBy;
    } else {
      const orderClauses = Object.entries(options.orderBy).map(([field, direction]) => `${camelToSnake(field)}.${direction}`);
      params.order = orderClauses.join(",");
    }
  }
  if (options.limit !== void 0) {
    params.limit = options.limit.toString();
  }
  if (options.offset !== void 0) {
    params.offset = options.offset.toString();
  }
  if (options.cursor) {
    params.cursor = options.cursor;
  }
  return params;
}

// ../core/src/http-client.ts
function camelToSnake2(str) {
  return str.replace(/[A-Z]/g, (letter) => `_${letter.toLowerCase()}`);
}
function snakeToCamel(str) {
  return str.replace(/_([a-z])/g, (_, letter) => letter.toUpperCase());
}
function convertKeysToSnakeCase(obj) {
  if (obj === null || obj === void 0) return obj;
  if (typeof obj !== "object") return obj;
  if (Array.isArray(obj)) return obj.map(convertKeysToSnakeCase);
  const converted = {};
  for (const [key, value] of Object.entries(obj)) {
    const snakeKey = camelToSnake2(key);
    converted[snakeKey] = convertKeysToSnakeCase(value);
  }
  return converted;
}
function convertKeysToCamelCase(obj) {
  if (obj === null || obj === void 0) return obj;
  if (typeof obj !== "object") return obj;
  if (Array.isArray(obj)) return obj.map(convertKeysToCamelCase);
  const converted = {};
  for (const [key, value] of Object.entries(obj)) {
    const camelKey = snakeToCamel(key);
    converted[camelKey] = convertKeysToCamelCase(value);
  }
  return converted;
}
var HttpClient = class {
  authUrl = "https://blink.new";
  coreUrl = "https://core.blink.new";
  projectId;
  getToken;
  getValidToken;
  constructor(config, getToken, getValidToken) {
    this.projectId = config.projectId;
    this.getToken = getToken;
    this.getValidToken = getValidToken;
  }
  /**
   * Make an authenticated request to the Blink API
   */
  async request(path, options = {}) {
    const url = this.buildUrl(path, options.searchParams);
    const token = this.getValidToken ? await this.getValidToken() : this.getToken();
    const headers = {
      "Content-Type": "application/json",
      ...options.headers
    };
    if (token) {
      headers.Authorization = `Bearer ${token}`;
    }
    const requestInit = {
      method: options.method || "GET",
      headers,
      signal: options.signal
    };
    if (options.body && options.method !== "GET") {
      requestInit.body = typeof options.body === "string" ? options.body : JSON.stringify(options.body);
    }
    try {
      const response = await fetch(url, requestInit);
      if (!response.ok) {
        await this.handleErrorResponse(response);
      }
      const data = await this.parseResponse(response);
      return {
        data,
        status: response.status,
        headers: response.headers
      };
    } catch (error) {
      if (error instanceof BlinkError) {
        throw error;
      }
      throw new BlinkNetworkError(
        `Network request failed: ${error instanceof Error ? error.message : "Unknown error"}`,
        0,
        { originalError: error }
      );
    }
  }
  /**
   * GET request
   */
  async get(path, searchParams) {
    return this.request(path, { method: "GET", searchParams });
  }
  /**
   * POST request
   */
  async post(path, body, headers) {
    return this.request(path, { method: "POST", body, headers });
  }
  /**
   * PATCH request
   */
  async patch(path, body, headers) {
    return this.request(path, { method: "PATCH", body, headers });
  }
  /**
   * DELETE request
   */
  async delete(path, searchParams) {
    return this.request(path, { method: "DELETE", searchParams });
  }
  /**
   * Database-specific requests
   */
  // Table operations (PostgREST-compatible)
  async dbGet(table, searchParams) {
    const response = await this.get(`/api/db/${this.projectId}/rest/v1/${table}`, searchParams);
    const convertedData = convertKeysToCamelCase(response.data);
    return {
      ...response,
      data: convertedData
    };
  }
  async dbPost(table, body, options = {}) {
    const headers = {};
    if (options.returning) {
      headers.Prefer = "return=representation";
    }
    const convertedBody = convertKeysToSnakeCase(body);
    const response = await this.post(`/api/db/${this.projectId}/rest/v1/${table}`, convertedBody, headers);
    const convertedData = convertKeysToCamelCase(response.data);
    return {
      ...response,
      data: convertedData
    };
  }
  async dbPatch(table, body, searchParams, options = {}) {
    const headers = {};
    if (options.returning) {
      headers.Prefer = "return=representation";
    }
    const convertedBody = convertKeysToSnakeCase(body);
    const response = await this.request(`/api/db/${this.projectId}/rest/v1/${table}`, {
      method: "PATCH",
      body: convertedBody,
      headers,
      searchParams
    });
    const convertedData = convertKeysToCamelCase(response.data);
    return {
      ...response,
      data: convertedData
    };
  }
  async dbDelete(table, searchParams, options = {}) {
    const headers = {};
    if (options.returning) {
      headers.Prefer = "return=representation";
    }
    const response = await this.request(`/api/db/${this.projectId}/rest/v1/${table}`, {
      method: "DELETE",
      headers,
      searchParams
    });
    const convertedData = convertKeysToCamelCase(response.data);
    return {
      ...response,
      data: convertedData
    };
  }
  // Raw SQL operations
  async dbSql(query, params) {
    const response = await this.post(`/api/db/${this.projectId}/sql`, { query, params });
    const convertedData = {
      ...response.data,
      rows: convertKeysToCamelCase(response.data.rows)
    };
    return {
      ...response,
      data: convertedData
    };
  }
  // Batch SQL operations
  async dbBatch(statements, mode = "write") {
    const response = await this.post(`/api/db/${this.projectId}/batch`, { statements, mode });
    const convertedData = {
      ...response.data,
      results: response.data.results.map((result) => ({
        ...result,
        rows: convertKeysToCamelCase(result.rows)
      }))
    };
    return {
      ...response,
      data: convertedData
    };
  }
  /**
   * Upload file with progress tracking
   */
  async uploadFile(path, file, filePath, options = {}) {
    const url = this.buildUrl(path);
    const token = this.getValidToken ? await this.getValidToken() : this.getToken();
    const formData = new FormData();
    if (file instanceof File) {
      formData.append("file", file);
    } else if (file instanceof Blob) {
      const blobWithType = options.contentType ? new Blob([file], { type: options.contentType }) : file;
      formData.append("file", blobWithType);
    } else if (typeof Buffer !== "undefined" && file instanceof Buffer) {
      const blob = new Blob([file], { type: options.contentType || "application/octet-stream" });
      formData.append("file", blob);
    } else {
      throw new BlinkValidationError("Unsupported file type");
    }
    formData.append("path", filePath);
    if (options.upsert !== void 0) {
      formData.append("options", JSON.stringify({ upsert: options.upsert }));
    }
    const headers = {};
    if (token) {
      headers.Authorization = `Bearer ${token}`;
    }
    try {
      if (typeof XMLHttpRequest !== "undefined" && options.onProgress) {
        return this.uploadWithProgress(url, formData, headers, options.onProgress);
      }
      const response = await fetch(url, {
        method: "POST",
        headers,
        body: formData
      });
      if (!response.ok) {
        await this.handleErrorResponse(response);
      }
      const data = await this.parseResponse(response);
      return {
        data,
        status: response.status,
        headers: response.headers
      };
    } catch (error) {
      if (error instanceof BlinkError) {
        throw error;
      }
      throw new BlinkNetworkError(
        `File upload failed: ${error instanceof Error ? error.message : "Unknown error"}`,
        0,
        { originalError: error }
      );
    }
  }
  /**
   * Upload with progress tracking using XMLHttpRequest
   */
  uploadWithProgress(url, formData, headers, onProgress) {
    return new Promise((resolve, reject) => {
      const xhr = new XMLHttpRequest();
      xhr.upload.addEventListener("progress", (event) => {
        if (event.lengthComputable) {
          const percent = Math.round(event.loaded / event.total * 100);
          onProgress(percent);
        }
      });
      xhr.addEventListener("load", async () => {
        if (xhr.status >= 200 && xhr.status < 300) {
          try {
            const data = JSON.parse(xhr.responseText);
            resolve({
              data,
              status: xhr.status,
              headers: new Headers()
              // XMLHttpRequest doesn't provide easy access to response headers
            });
          } catch (error) {
            reject(new BlinkNetworkError("Failed to parse response", xhr.status));
          }
        } else {
          try {
            const errorData = JSON.parse(xhr.responseText);
            const message = errorData.error?.message || errorData.message || `HTTP ${xhr.status}`;
            switch (xhr.status) {
              case 401:
                reject(new BlinkAuthError(message, errorData));
                break;
              case 400:
                reject(new BlinkValidationError(message, errorData));
                break;
              default:
                reject(new BlinkNetworkError(message, xhr.status, errorData));
            }
          } catch {
            reject(new BlinkNetworkError(`HTTP ${xhr.status}`, xhr.status));
          }
        }
      });
      xhr.addEventListener("error", () => {
        reject(new BlinkNetworkError("Network error during file upload"));
      });
      xhr.open("POST", url);
      Object.entries(headers).forEach(([key, value]) => {
        xhr.setRequestHeader(key, value);
      });
      xhr.send(formData);
    });
  }
  /**
   * AI-specific requests
   */
  async aiText(prompt, options = {}) {
    const { signal, ...body } = options;
    const requestBody = { ...body };
    if (prompt) {
      requestBody.prompt = prompt;
    }
    return this.request(`/api/ai/${this.projectId}/text`, {
      method: "POST",
      body: requestBody,
      signal
    });
  }
  /**
   * Stream AI text generation with Vercel AI SDK data stream format
   */
  async streamAiText(prompt, options = {}, onChunk) {
    const url = this.buildUrl(`/api/ai/${this.projectId}/text`);
    const token = this.getValidToken ? await this.getValidToken() : this.getToken();
    const headers = {
      "Content-Type": "application/json"
    };
    if (token) {
      headers.Authorization = `Bearer ${token}`;
    }
    const body = {
      prompt,
      stream: true,
      ...options
    };
    const { signal: _signal, ...jsonBody } = body;
    try {
      const response = await fetch(url, {
        method: "POST",
        headers,
        body: JSON.stringify(jsonBody),
        signal: options.signal
      });
      if (!response.ok) {
        await this.handleErrorResponse(response);
      }
      if (!response.body) {
        throw new BlinkNetworkError("No response body for streaming");
      }
      return this.parseDataStream(response.body, onChunk);
    } catch (error) {
      if (error instanceof BlinkError) {
        throw error;
      }
      throw new BlinkNetworkError(
        `Streaming request failed: ${error instanceof Error ? error.message : "Unknown error"}`,
        0,
        { originalError: error }
      );
    }
  }
  async aiObject(prompt, options = {}) {
    const { signal, ...body } = options;
    const requestBody = { ...body };
    if (prompt) {
      requestBody.prompt = prompt;
    }
    return this.request(`/api/ai/${this.projectId}/object`, {
      method: "POST",
      body: requestBody,
      signal
    });
  }
  /**
   * Stream AI object generation with Vercel AI SDK data stream format
   */
  async streamAiObject(prompt, options = {}, onPartial) {
    const url = this.buildUrl(`/api/ai/${this.projectId}/object`);
    const token = this.getValidToken ? await this.getValidToken() : this.getToken();
    const headers = {
      "Content-Type": "application/json"
    };
    if (token) {
      headers.Authorization = `Bearer ${token}`;
    }
    const body = {
      prompt,
      stream: true,
      ...options
    };
    const { signal: _signal2, ...jsonBody2 } = body;
    try {
      const response = await fetch(url, {
        method: "POST",
        headers,
        body: JSON.stringify(jsonBody2),
        signal: options.signal
      });
      if (!response.ok) {
        await this.handleErrorResponse(response);
      }
      if (!response.body) {
        throw new BlinkNetworkError("No response body for streaming");
      }
      return this.parseDataStream(response.body, void 0, onPartial);
    } catch (error) {
      if (error instanceof BlinkError) {
        throw error;
      }
      throw new BlinkNetworkError(
        `Streaming request failed: ${error instanceof Error ? error.message : "Unknown error"}`,
        0,
        { originalError: error }
      );
    }
  }
  async aiImage(prompt, options = {}) {
    const { signal, ...body } = options;
    return this.request(`/api/ai/${this.projectId}/image`, {
      method: "POST",
      body: {
        prompt,
        ...body
      },
      signal
    });
  }
  async aiSpeech(text, options = {}) {
    const { signal, ...body } = options;
    return this.request(`/api/ai/${this.projectId}/speech`, {
      method: "POST",
      body: {
        text,
        ...body
      },
      signal
    });
  }
  async aiTranscribe(audio, options = {}) {
    const { signal, ...body } = options;
    let payloadAudio;
    if (typeof audio === "string" || Array.isArray(audio)) {
      payloadAudio = audio;
    } else if (audio instanceof Uint8Array) {
      payloadAudio = Array.from(audio);
    } else if (audio instanceof ArrayBuffer) {
      payloadAudio = Array.from(new Uint8Array(audio));
    } else if (typeof Buffer !== "undefined" && Buffer.isBuffer(audio)) {
      payloadAudio = Array.from(new Uint8Array(audio));
    } else {
      throw new BlinkValidationError("Unsupported audio input type");
    }
    return this.request(`/api/ai/${this.projectId}/transcribe`, {
      method: "POST",
      body: {
        audio: payloadAudio,
        ...body
      },
      signal
    });
  }
  /**
   * Data-specific requests
   */
  async dataExtractFromUrl(projectId, request) {
    return this.request(`/api/data/${projectId}/extract-from-url`, {
      method: "POST",
      body: JSON.stringify(request)
    });
  }
  async dataExtractFromBlob(projectId, file, chunking, chunkSize) {
    const formData = new FormData();
    formData.append("file", file);
    if (chunking !== void 0) {
      formData.append("chunking", String(chunking));
    }
    if (chunkSize !== void 0) {
      formData.append("chunkSize", String(chunkSize));
    }
    return this.request(`/api/data/${projectId}/extract-from-blob`, {
      method: "POST",
      body: formData
    });
  }
  async dataScrape(projectId, request) {
    return this.request(`/api/data/${projectId}/scrape`, {
      method: "POST",
      body: JSON.stringify(request)
    });
  }
  async dataScreenshot(projectId, request) {
    return this.request(`/api/data/${projectId}/screenshot`, {
      method: "POST",
      body: JSON.stringify(request)
    });
  }
  async dataFetch(projectId, request) {
    return this.post(`/api/data/${projectId}/fetch`, request);
  }
  async dataSearch(projectId, request) {
    return this.post(`/api/data/${projectId}/search`, request);
  }
  /**
   * Realtime-specific requests
   */
  async realtimePublish(projectId, request) {
    return this.post(`/api/realtime/${projectId}/publish`, request);
  }
  async realtimeGetPresence(projectId, channel) {
    return this.get(`/api/realtime/${projectId}/presence`, { channel });
  }
  async realtimeGetMessages(projectId, options) {
    const { channel, ...searchParams } = options;
    return this.get(`/api/realtime/${projectId}/messages`, {
      channel,
      ...Object.fromEntries(
        Object.entries(searchParams).filter(([k, v]) => v !== void 0).map(([k, v]) => [k, String(v)])
      )
    });
  }
  /**
   * Private helper methods
   */
  buildUrl(path, searchParams) {
    const baseUrl = path.includes("/api/auth/") ? this.authUrl : this.coreUrl;
    const url = new URL(path, baseUrl);
    if (searchParams) {
      Object.entries(searchParams).forEach(([key, value]) => {
        url.searchParams.set(key, value);
      });
    }
    return url.toString();
  }
  async parseResponse(response) {
    const contentType = response.headers.get("content-type");
    if (contentType?.includes("application/json")) {
      return response.json();
    }
    if (contentType?.includes("text/")) {
      return response.text();
    }
    return response.blob();
  }
  async handleErrorResponse(response) {
    let errorData;
    try {
      const contentType = response.headers.get("content-type");
      if (contentType?.includes("application/json")) {
        errorData = await response.json();
      } else {
        errorData = { message: await response.text() };
      }
    } catch {
      errorData = { message: "Unknown error occurred" };
    }
    const message = errorData.error?.message || errorData.message || `HTTP ${response.status}`;
    errorData.error?.code || errorData.code;
    switch (response.status) {
      case 401:
        throw new BlinkAuthError(message, errorData);
      case 400:
        throw new BlinkValidationError(message, errorData);
      default:
        throw new BlinkNetworkError(message, response.status, errorData);
    }
  }
  /**
   * Parse Vercel AI SDK data stream format
   * Handles text chunks (0:"text"), partial objects (2:[...]), and metadata (d:, e:)
   */
  async parseDataStream(body, onChunk, onPartial) {
    const reader = body.getReader();
    const decoder = new TextDecoder();
    let buffer = "";
    let finalResult = {};
    try {
      while (true) {
        const { done, value } = await reader.read();
        if (done) break;
        buffer += decoder.decode(value, { stream: true });
        const lines = buffer.split(/\r?\n/);
        buffer = lines.pop() || "";
        for (const line of lines) {
          if (!line.trim()) continue;
          try {
            if (line.startsWith("f:")) {
              const metadata = JSON.parse(line.slice(2));
              finalResult.messageId = metadata.messageId;
            } else if (line.startsWith("0:")) {
              const textChunk = JSON.parse(line.slice(2));
              if (onChunk) {
                onChunk(textChunk);
              }
              finalResult.text = (finalResult.text || "") + textChunk;
            } else if (line.startsWith("2:")) {
              const data = JSON.parse(line.slice(2));
              if (Array.isArray(data) && data.length > 0) {
                const item = data[0];
                if (typeof item === "string") {
                  finalResult.status = item;
                } else if (typeof item === "object") {
                  if (onPartial) {
                    onPartial(item);
                  }
                  finalResult.object = item;
                }
              }
            } else if (line.startsWith("d:")) {
              const metadata = JSON.parse(line.slice(2));
              if (metadata.usage) {
                finalResult.usage = metadata.usage;
              }
              if (metadata.finishReason) {
                finalResult.finishReason = metadata.finishReason;
              }
            } else if (line.startsWith("e:")) {
              const errorData = JSON.parse(line.slice(2));
              finalResult.error = errorData;
            }
          } catch (error) {
            console.warn("Failed to parse stream line:", line, error);
          }
        }
      }
      if (buffer.trim()) {
        try {
          if (buffer.startsWith("0:")) {
            const textChunk = JSON.parse(buffer.slice(2));
            if (onChunk) {
              onChunk(textChunk);
            }
            finalResult.text = (finalResult.text || "") + textChunk;
          } else if (buffer.startsWith("2:")) {
            const data = JSON.parse(buffer.slice(2));
            if (Array.isArray(data) && data.length > 0) {
              const item = data[0];
              if (typeof item === "object") {
                if (onPartial) {
                  onPartial(item);
                }
                finalResult.object = item;
              }
            }
          } else if (buffer.startsWith("d:")) {
            const metadata = JSON.parse(buffer.slice(2));
            if (metadata.usage) {
              finalResult.usage = metadata.usage;
            }
            if (metadata.finishReason) {
              finalResult.finishReason = metadata.finishReason;
            }
          }
        } catch (error) {
          console.warn("Failed to parse final buffer:", buffer, error);
        }
      }
      return finalResult;
    } finally {
      reader.releaseLock();
    }
  }
};

// src/auth.ts
var BlinkAuth = class {
  config;
  authState;
  listeners = /* @__PURE__ */ new Set();
  authUrl = "https://blink.new";
  parentWindowTokens = null;
  isIframe = false;
  initializationPromise = null;
  isInitialized = false;
  constructor(config) {
    this.config = config;
    this.authState = {
      user: null,
      tokens: null,
      isAuthenticated: false,
      isLoading: false
    };
    if (typeof window !== "undefined") {
      this.isIframe = window.self !== window.top;
      this.setupParentWindowListener();
      this.initializationPromise = this.initialize();
    } else {
      this.isInitialized = true;
    }
  }
  /**
   * Wait for authentication initialization to complete
   */
  async waitForInitialization() {
    if (this.isInitialized) return;
    if (this.initializationPromise) {
      await this.initializationPromise;
    }
  }
  /**
   * Setup listener for tokens from parent window
   */
  setupParentWindowListener() {
    if (!this.isIframe) return;
    window.addEventListener("message", (event) => {
      if (event.origin !== "https://blink.new" && event.origin !== "http://localhost:3000" && event.origin !== "http://localhost:3001") {
        return;
      }
      if (event.data?.type === "BLINK_AUTH_TOKENS") {
        console.log("\u{1F4E5} Received auth tokens from parent window");
        const { tokens } = event.data;
        if (tokens) {
          this.parentWindowTokens = tokens;
          this.setTokens(tokens, false).then(() => {
            console.log("\u2705 Tokens from parent window applied");
          }).catch((error) => {
            console.error("Failed to apply parent window tokens:", error);
          });
        }
      }
      if (event.data?.type === "BLINK_AUTH_LOGOUT") {
        console.log("\u{1F4E4} Received logout command from parent window");
        this.clearTokens();
      }
    });
    if (window.parent !== window) {
      console.log("\u{1F504} Requesting auth tokens from parent window");
      window.parent.postMessage({
        type: "BLINK_REQUEST_AUTH_TOKENS",
        projectId: this.config.projectId
      }, "*");
    }
  }
  /**
   * Initialize authentication from stored tokens or URL fragments
   */
  async initialize() {
    console.log("\u{1F680} Initializing Blink Auth...");
    this.setLoading(true);
    try {
      if (this.isIframe) {
        console.log("\u{1F50D} Detected iframe environment, waiting for parent tokens...");
        await new Promise((resolve) => setTimeout(resolve, 100));
        if (this.parentWindowTokens) {
          console.log("\u2705 Using tokens from parent window");
          await this.setTokens(this.parentWindowTokens, false);
          return;
        }
      }
      const tokensFromUrl = this.extractTokensFromUrl();
      if (tokensFromUrl) {
        console.log("\u{1F4E5} Found tokens in URL, setting them...");
        await this.setTokens(tokensFromUrl, true);
        this.clearUrlTokens();
        console.log("\u2705 Auth initialization complete (from URL)");
        return;
      }
      const storedTokens = this.getStoredTokens();
      if (storedTokens) {
        console.log("\u{1F4BE} Found stored tokens, validating...", {
          hasAccessToken: !!storedTokens.access_token,
          hasRefreshToken: !!storedTokens.refresh_token,
          issuedAt: storedTokens.issued_at,
          expiresIn: storedTokens.expires_in,
          refreshExpiresIn: storedTokens.refresh_expires_in,
          currentTime: Math.floor(Date.now() / 1e3)
        });
        this.authState.tokens = storedTokens;
        console.log("\u{1F527} Tokens set in auth state, refresh token available:", !!this.authState.tokens?.refresh_token);
        const isValid = await this.validateStoredTokens(storedTokens);
        if (isValid) {
          console.log("\u2705 Auth initialization complete (from storage)");
          return;
        } else {
          console.log("\u{1F504} Stored tokens invalid, clearing...");
          this.clearTokens();
        }
      }
      console.log("\u274C No tokens found");
      if (this.config.authRequired) {
        console.log("\u{1F504} Auth required, redirecting to auth page...");
        this.redirectToAuth();
      } else {
        console.log("\u26A0\uFE0F Auth not required, continuing without authentication");
      }
    } finally {
      this.setLoading(false);
      this.isInitialized = true;
    }
  }
  /**
   * Redirect to Blink auth page
   */
  login(nextUrl) {
    let redirectUrl = nextUrl;
    if (!redirectUrl && typeof window !== "undefined") {
      if (window.location.href.startsWith("http")) {
        redirectUrl = window.location.href;
      } else {
        redirectUrl = `${window.location.protocol}//${window.location.host}${window.location.pathname}${window.location.search}${window.location.hash}`;
      }
    }
    if (redirectUrl && typeof window !== "undefined") {
      try {
        const url = new URL(redirectUrl);
        url.searchParams.delete("redirect_url");
        url.searchParams.delete("redirect");
        redirectUrl = url.toString();
      } catch (e) {
        console.warn("Failed to parse redirect URL:", e);
      }
    }
    const authUrl = new URL("/auth", this.authUrl);
    authUrl.searchParams.set("redirect_url", redirectUrl || "");
    if (this.config.projectId) {
      authUrl.searchParams.set("project_id", this.config.projectId);
    }
    if (typeof window !== "undefined") {
      window.location.href = authUrl.toString();
    }
  }
  /**
   * Logout and clear stored tokens
   */
  logout(redirectUrl) {
    this.clearTokens();
    if (redirectUrl && typeof window !== "undefined") {
      window.location.href = redirectUrl;
    }
  }
  /**
   * Check if user is authenticated
   */
  isAuthenticated() {
    return this.authState.isAuthenticated;
  }
  /**
   * Get current user (sync)
   */
  currentUser() {
    return this.authState.user;
  }
  /**
   * Get current access token
   */
  getToken() {
    return this.authState.tokens?.access_token || null;
  }
  /**
   * Check if access token is expired based on timestamp
   */
  isAccessTokenExpired() {
    const tokens = this.authState.tokens;
    if (!tokens || !tokens.issued_at) {
      return true;
    }
    const now = Math.floor(Date.now() / 1e3);
    const expiresAt = tokens.issued_at + tokens.expires_in;
    const bufferTime = 30;
    return now >= expiresAt - bufferTime;
  }
  /**
   * Check if refresh token is expired based on timestamp
   */
  isRefreshTokenExpired() {
    const tokens = this.authState.tokens;
    if (!tokens || !tokens.refresh_token || !tokens.issued_at || !tokens.refresh_expires_in) {
      return true;
    }
    const now = Math.floor(Date.now() / 1e3);
    const expiresAt = tokens.issued_at + tokens.refresh_expires_in;
    return now >= expiresAt;
  }
  /**
   * Get a valid access token, refreshing if necessary
   */
  async getValidToken() {
    const tokens = this.authState.tokens;
    if (!tokens) {
      return null;
    }
    if (!this.isAccessTokenExpired()) {
      console.log("\u2705 Access token is still valid");
      return tokens.access_token;
    }
    console.log("\u23F0 Access token expired, attempting refresh...");
    if (this.isRefreshTokenExpired()) {
      console.log("\u274C Refresh token also expired, clearing tokens");
      this.clearTokens();
      if (this.config.authRequired) {
        this.redirectToAuth();
      }
      return null;
    }
    const refreshed = await this.refreshToken();
    if (refreshed) {
      console.log("\u2705 Token refreshed successfully");
      return this.authState.tokens?.access_token || null;
    } else {
      console.log("\u274C Token refresh failed");
      this.clearTokens();
      if (this.config.authRequired) {
        this.redirectToAuth();
      }
      return null;
    }
  }
  /**
   * Fetch current user profile from API
   * Gracefully waits for auth initialization to complete before throwing errors
   */
  async me() {
    await this.waitForInitialization();
    if (this.authState.isAuthenticated && this.authState.user) {
      return this.authState.user;
    }
    if (!this.authState.isAuthenticated) {
      return new Promise((resolve, reject) => {
        if (this.authState.user) {
          resolve(this.authState.user);
          return;
        }
        const timeout = setTimeout(() => {
          unsubscribe();
          reject(new BlinkAuthError("Authentication timeout - no user available"));
        }, 5e3);
        const unsubscribe = this.onAuthStateChanged((state) => {
          if (state.user) {
            clearTimeout(timeout);
            unsubscribe();
            resolve(state.user);
          } else if (!state.isLoading && !state.isAuthenticated) {
            clearTimeout(timeout);
            unsubscribe();
            reject(new BlinkAuthError("Not authenticated"));
          }
        });
      });
    }
    let token = this.getToken();
    if (!token) {
      throw new BlinkAuthError("No access token available");
    }
    try {
      const response = await fetch(`${this.authUrl}/api/auth/me`, {
        headers: {
          "Authorization": `Bearer ${token}`
        }
      });
      if (!response.ok) {
        if (response.status === 401) {
          const refreshed = await this.refreshToken();
          if (refreshed) {
            token = this.getToken();
            if (token) {
              const retryResponse = await fetch(`${this.authUrl}/api/auth/me`, {
                headers: {
                  "Authorization": `Bearer ${token}`
                }
              });
              if (retryResponse.ok) {
                const retryData = await retryResponse.json();
                const user2 = retryData.user;
                this.updateAuthState({
                  ...this.authState,
                  user: user2
                });
                return user2;
              }
            }
          }
          this.clearTokens();
          if (this.config.authRequired) {
            this.redirectToAuth();
          }
        }
        throw new BlinkAuthError(`Failed to fetch user: ${response.statusText}`);
      }
      const data = await response.json();
      const user = data.user;
      this.updateAuthState({
        ...this.authState,
        user
      });
      return user;
    } catch (error) {
      if (error instanceof BlinkAuthError) {
        throw error;
      }
      throw new BlinkAuthError(`Network error: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
  /**
   * Update user profile
   */
  async updateMe(updates) {
    const token = this.getToken();
    if (!token) {
      throw new BlinkAuthError("No access token available");
    }
    try {
      const response = await fetch(`${this.authUrl}/api/auth/me`, {
        method: "PATCH",
        headers: {
          "Authorization": `Bearer ${token}`,
          "Content-Type": "application/json"
        },
        body: JSON.stringify(updates)
      });
      if (!response.ok) {
        throw new BlinkAuthError(`Failed to update user: ${response.statusText}`);
      }
      const data = await response.json();
      const user = data.user;
      this.updateAuthState({
        ...this.authState,
        user
      });
      return user;
    } catch (error) {
      if (error instanceof BlinkAuthError) {
        throw error;
      }
      throw new BlinkAuthError(`Network error: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
  /**
   * Manually set tokens (for server-side usage)
   */
  async setToken(jwt, persist = false) {
    const tokens = {
      access_token: jwt,
      token_type: "Bearer",
      expires_in: 15 * 60
      // Default 15 minutes
    };
    await this.setTokens(tokens, persist);
  }
  /**
   * Refresh access token using refresh token
   */
  async refreshToken() {
    const refreshToken = this.authState.tokens?.refresh_token;
    if (!refreshToken) {
      return false;
    }
    try {
      const response = await fetch(`${this.authUrl}/api/auth/refresh`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          refresh_token: refreshToken
        })
      });
      if (!response.ok) {
        if (response.status === 401) {
          this.clearTokens();
          if (this.config.authRequired) {
            this.redirectToAuth();
          }
        }
        return false;
      }
      const data = await response.json();
      await this.setTokens({
        access_token: data.access_token,
        refresh_token: data.refresh_token,
        token_type: data.token_type,
        expires_in: data.expires_in,
        refresh_expires_in: data.refresh_expires_in
      }, true);
      return true;
    } catch (error) {
      console.error("Token refresh failed:", error);
      return false;
    }
  }
  /**
   * Add auth state change listener
   */
  onAuthStateChanged(callback) {
    this.listeners.add(callback);
    queueMicrotask(() => {
      try {
        callback(this.authState);
      } catch (error) {
        console.error("Error in auth state change callback:", error);
      }
    });
    return () => {
      this.listeners.delete(callback);
    };
  }
  /**
   * Private helper methods
   */
  async validateStoredTokens(tokens) {
    try {
      console.log("\u{1F50D} Validating stored tokens...");
      if (this.isAccessTokenExpired()) {
        console.log("\u23F0 Access token expired based on timestamp, attempting refresh...");
        if (!tokens.refresh_token) {
          console.log("\u274C No refresh token available");
          return false;
        }
        if (this.isRefreshTokenExpired()) {
          console.log("\u274C Refresh token also expired");
          return false;
        }
        const refreshed = await this.refreshToken();
        if (refreshed) {
          console.log("\u2705 Token refreshed successfully during validation");
          return true;
        } else {
          console.log("\u274C Token refresh failed during validation");
          return false;
        }
      }
      const response = await fetch(`${this.authUrl}/api/auth/me`, {
        headers: {
          "Authorization": `Bearer ${tokens.access_token}`
        }
      });
      if (response.ok) {
        const data = await response.json();
        const user = data.user;
        this.updateAuthState({
          user,
          tokens,
          isAuthenticated: true,
          isLoading: false
        });
        console.log("\u2705 Stored tokens are valid, user authenticated");
        return true;
      } else if (response.status === 401 && tokens.refresh_token) {
        console.log("\u{1F504} Access token expired (server validation), attempting refresh...");
        if (this.isRefreshTokenExpired()) {
          console.log("\u274C Refresh token expired");
          return false;
        }
        const refreshed = await this.refreshToken();
        if (refreshed) {
          console.log("\u2705 Token refreshed successfully after server validation");
          return true;
        } else {
          console.log("\u274C Token refresh failed after server validation");
          return false;
        }
      } else {
        console.log("\u274C Token validation failed:", response.status, response.statusText);
        return false;
      }
    } catch (error) {
      console.log("\u{1F4A5} Error validating tokens:", error);
      return false;
    }
  }
  async setTokens(tokens, persist) {
    const tokensWithTimestamp = {
      ...tokens,
      issued_at: tokens.issued_at || Math.floor(Date.now() / 1e3)
    };
    console.log("\u{1F510} Setting tokens:", {
      persist,
      hasAccessToken: !!tokensWithTimestamp.access_token,
      hasRefreshToken: !!tokensWithTimestamp.refresh_token,
      expiresIn: tokensWithTimestamp.expires_in,
      issuedAt: tokensWithTimestamp.issued_at
    });
    if (persist && typeof window !== "undefined") {
      try {
        localStorage.setItem("blink_tokens", JSON.stringify(tokensWithTimestamp));
        console.log("\u{1F4BE} Tokens persisted to localStorage");
      } catch (error) {
        console.log("\u{1F4A5} Error persisting tokens to localStorage:", error);
        if (error instanceof DOMException && error.name === "SecurityError") {
          console.log("\u{1F6AB} localStorage access blocked - running in cross-origin iframe");
        }
      }
    }
    let user = null;
    try {
      console.log("\u{1F464} Fetching user data...");
      const response = await fetch(`${this.authUrl}/api/auth/me`, {
        headers: {
          "Authorization": `Bearer ${tokensWithTimestamp.access_token}`
        }
      });
      console.log("\u{1F4E1} User fetch response:", {
        status: response.status,
        statusText: response.statusText,
        ok: response.ok
      });
      if (response.ok) {
        const data = await response.json();
        user = data.user;
        console.log("\u2705 User data fetched successfully:", {
          id: user?.id,
          email: user?.email,
          displayName: user?.displayName
        });
      } else {
        console.log("\u274C Failed to fetch user data:", await response.text());
      }
    } catch (error) {
      console.log("\u{1F4A5} Error fetching user data:", error);
    }
    this.updateAuthState({
      user,
      tokens: tokensWithTimestamp,
      isAuthenticated: !!user,
      isLoading: false
    });
    console.log("\u{1F3AF} Auth state updated:", {
      hasUser: !!user,
      isAuthenticated: !!user,
      isLoading: false
    });
  }
  clearTokens() {
    if (typeof window !== "undefined") {
      try {
        localStorage.removeItem("blink_tokens");
      } catch (error) {
        console.log("\u{1F4A5} Error clearing tokens from localStorage:", error);
      }
    }
    this.updateAuthState({
      user: null,
      tokens: null,
      isAuthenticated: false,
      isLoading: false
    });
  }
  getStoredTokens() {
    if (typeof window === "undefined") return null;
    if (this.isIframe && this.parentWindowTokens) {
      return this.parentWindowTokens;
    }
    try {
      const stored = localStorage.getItem("blink_tokens");
      console.log("\u{1F50D} Checking localStorage for tokens:", {
        hasStoredData: !!stored,
        storedLength: stored?.length || 0,
        origin: window.location.origin,
        isIframe: window.self !== window.top
      });
      if (stored) {
        const tokens = JSON.parse(stored);
        console.log("\u{1F4E6} Parsed stored tokens:", {
          hasAccessToken: !!tokens.access_token,
          hasRefreshToken: !!tokens.refresh_token,
          tokenType: tokens.token_type,
          expiresIn: tokens.expires_in
        });
        return tokens;
      }
      return null;
    } catch (error) {
      console.log("\u{1F4A5} Error accessing localStorage:", error);
      if (error instanceof DOMException && error.name === "SecurityError") {
        console.log("\u{1F6AB} localStorage access blocked - likely due to cross-origin iframe restrictions");
      }
      return null;
    }
  }
  extractTokensFromUrl() {
    if (typeof window === "undefined") return null;
    const params = new URLSearchParams(window.location.search);
    const accessToken = params.get("access_token");
    const refreshToken = params.get("refresh_token");
    console.log("\u{1F50D} Extracting tokens from URL:", {
      url: window.location.href,
      accessToken: accessToken ? `${accessToken.substring(0, 20)}...` : null,
      refreshToken: refreshToken ? `${refreshToken.substring(0, 20)}...` : null,
      allParams: Object.fromEntries(params.entries())
    });
    if (accessToken) {
      const tokens = {
        access_token: accessToken,
        refresh_token: refreshToken || void 0,
        token_type: "Bearer",
        expires_in: 15 * 60,
        // 15 minutes default
        refresh_expires_in: refreshToken ? 30 * 24 * 60 * 60 : void 0,
        // 30 days default
        issued_at: Math.floor(Date.now() / 1e3)
        // Current timestamp
      };
      console.log("\u2705 Tokens extracted successfully:", {
        hasAccessToken: !!tokens.access_token,
        hasRefreshToken: !!tokens.refresh_token
      });
      return tokens;
    }
    console.log("\u274C No access token found in URL");
    return null;
  }
  clearUrlTokens() {
    if (typeof window === "undefined") return;
    const url = new URL(window.location.href);
    url.searchParams.delete("access_token");
    url.searchParams.delete("refresh_token");
    url.searchParams.delete("token_type");
    url.searchParams.delete("project_id");
    url.searchParams.delete("expires_in");
    url.searchParams.delete("refresh_expires_in");
    url.searchParams.delete("state");
    url.searchParams.delete("code");
    url.searchParams.delete("error");
    url.searchParams.delete("error_description");
    window.history.replaceState({}, "", url.toString());
    console.log("\u{1F9F9} URL cleaned up, removed auth parameters");
  }
  redirectToAuth() {
    if (typeof window !== "undefined") {
      this.login();
    }
  }
  setLoading(loading) {
    this.updateAuthState({
      ...this.authState,
      isLoading: loading
    });
  }
  updateAuthState(newState) {
    this.authState = newState;
    this.listeners.forEach((callback) => {
      try {
        callback(newState);
      } catch (error) {
        console.error("Error in auth state change callback:", error);
      }
    });
  }
};

// src/database.ts
function camelToSnake3(str) {
  return str.replace(/[A-Z]/g, (letter) => `_${letter.toLowerCase()}`);
}
function generateSecureId() {
  if (typeof crypto !== "undefined" && crypto.getRandomValues) {
    const array = new Uint8Array(16);
    crypto.getRandomValues(array);
    return Array.from(array, (byte) => byte.toString(16).padStart(2, "0")).join("");
  } else {
    const timestamp = Date.now().toString(36);
    const randomPart = Math.random().toString(36).substring(2, 15);
    const extraRandom = Math.random().toString(36).substring(2, 15);
    return `${timestamp}_${randomPart}_${extraRandom}`;
  }
}
function ensureRecordId(record) {
  if (!record.id) {
    return { ...record, id: generateSecureId() };
  }
  return record;
}
var BlinkTable = class {
  constructor(tableName, httpClient) {
    this.tableName = tableName;
    this.httpClient = httpClient;
    this.actualTableName = camelToSnake3(tableName);
  }
  actualTableName;
  /**
   * Create a single record
   */
  async create(data, options = {}) {
    const record = ensureRecordId(data);
    const response = await this.httpClient.dbPost(
      this.actualTableName,
      record,
      { returning: options.returning !== false }
    );
    const result = Array.isArray(response.data) ? response.data[0] : response.data;
    if (!result) {
      throw new Error("Failed to create record");
    }
    return result;
  }
  /**
   * Create multiple records
   */
  async createMany(data, options = {}) {
    const records = data.map(ensureRecordId);
    const response = await this.httpClient.dbPost(
      this.actualTableName,
      records,
      { returning: options.returning !== false }
    );
    const results = Array.isArray(response.data) ? response.data : [response.data];
    return results;
  }
  /**
   * Upsert a single record (insert or update on conflict)
   */
  async upsert(data, options = {}) {
    const headers = {};
    if (options.returning !== false) {
      headers.Prefer = "return=representation";
    }
    if (options.onConflict) {
      headers["Prefer"] = `${headers["Prefer"] || ""} resolution=merge-duplicates`.trim();
    }
    const record = ensureRecordId(data);
    const response = await this.httpClient.request(
      `/api/db/${this.httpClient.projectId}/rest/v1/${this.actualTableName}?on_conflict=${options.onConflict || "id"}`,
      {
        method: "POST",
        body: record,
        headers
      }
    );
    const result = Array.isArray(response.data) ? response.data[0] : response.data;
    if (!result) {
      throw new Error("Failed to upsert record");
    }
    return result;
  }
  /**
   * Upsert multiple records
   */
  async upsertMany(data, options = {}) {
    const records = data.map(ensureRecordId);
    const headers = {};
    if (options.returning !== false) {
      headers.Prefer = "return=representation";
    }
    if (options.onConflict) {
      headers["Prefer"] = `${headers["Prefer"] || ""} resolution=merge-duplicates`.trim();
    }
    const response = await this.httpClient.request(
      `/api/db/${this.httpClient.projectId}/rest/v1/${this.actualTableName}?on_conflict=${options.onConflict || "id"}`,
      {
        method: "POST",
        body: records,
        headers
      }
    );
    const results = Array.isArray(response.data) ? response.data : [response.data];
    return results;
  }
  /**
   * Get a single record by ID
   */
  async get(id) {
    const searchParams = {
      id: `eq.${id}`,
      limit: "1"
    };
    const response = await this.httpClient.dbGet(this.actualTableName, searchParams);
    const records = response.data;
    if (records.length === 0) {
      return null;
    }
    return records[0] || null;
  }
  /**
   * List records with filtering, sorting, and pagination
   */
  async list(options = {}) {
    const queryParams = buildQuery(options);
    const searchParams = queryParams;
    const response = await this.httpClient.dbGet(this.actualTableName, searchParams);
    const records = response.data;
    return records;
  }
  /**
   * Update a single record by ID
   */
  async update(id, data, options = {}) {
    const searchParams = {
      id: `eq.${id}`
    };
    const response = await this.httpClient.dbPatch(
      this.actualTableName,
      data,
      searchParams,
      { returning: options.returning !== false }
    );
    const records = response.data;
    if (!records || records.length === 0) {
      throw new Error(`Record with id ${id} not found`);
    }
    return records[0];
  }
  /**
   * Update multiple records
   */
  async updateMany(updates, options = {}) {
    const results = [];
    for (const update of updates) {
      const { id, ...data } = update;
      const result = await this.update(id, data, options);
      results.push(result);
    }
    return results;
  }
  /**
   * Delete a single record by ID
   */
  async delete(id) {
    const searchParams = {
      id: `eq.${id}`
    };
    await this.httpClient.dbDelete(this.actualTableName, searchParams);
  }
  /**
   * Delete multiple records based on filter
   */
  async deleteMany(options) {
    const queryParams = buildQuery({ where: options.where });
    const searchParams = queryParams;
    await this.httpClient.dbDelete(this.actualTableName, searchParams);
  }
  /**
   * Count records matching filter
   */
  async count(options = {}) {
    const queryParams = buildQuery({
      where: options.where,
      select: ["id"]
    });
    const response = await this.httpClient.request(
      `/api/db/${this.httpClient.projectId}/rest/v1/${this.actualTableName}`,
      {
        method: "GET",
        searchParams: queryParams,
        headers: {
          "Prefer": "count=exact"
        }
      }
    );
    const contentRange = response.headers.get("content-range");
    if (contentRange) {
      const match = contentRange.match(/\/(\d+)$/);
      if (match && match[1]) {
        return parseInt(match[1], 10);
      }
    }
    const records = response.data;
    return records.length;
  }
  /**
   * Check if any records exist matching filter
   */
  async exists(options) {
    const count = await this.count(options);
    return count > 0;
  }
  /**
   * Raw SQL query on this table (for advanced use cases)
   */
  async sql(query, params) {
    const response = await this.httpClient.dbSql(query, params);
    return response.data;
  }
  /**
   * Private helper methods
   */
  extractCursor(record) {
    return record.id || record._id || String(Math.random());
  }
};
var BlinkDatabase = class {
  constructor(httpClient) {
    this.httpClient = httpClient;
    const proxy = new Proxy(this, {
      get(target, prop) {
        if (prop === "table") {
          return target.table.bind(target);
        }
        if (prop in target) {
          const value = target[prop];
          return typeof value === "function" ? value.bind(target) : value;
        }
        if (typeof prop === "string") {
          return target.table(prop);
        }
        return void 0;
      }
    });
    return proxy;
  }
  tables = /* @__PURE__ */ new Map();
  /**
   * Get a table instance for any table name
   */
  table(tableName) {
    if (!this.tables.has(tableName)) {
      this.tables.set(tableName, new BlinkTable(tableName, this.httpClient));
    }
    const table = this.tables.get(tableName);
    if (!table) {
      throw new Error(`Table ${tableName} not found`);
    }
    return table;
  }
  /**
   * Execute raw SQL query
   */
  async sql(query, params) {
    const response = await this.httpClient.dbSql(query, params);
    return response.data;
  }
  /**
   * Execute batch SQL operations
   */
  async batch(statements, mode = "write") {
    const response = await this.httpClient.dbBatch(statements, mode);
    return response.data;
  }
};

// src/storage.ts
var BlinkStorageImpl = class {
  constructor(httpClient) {
    this.httpClient = httpClient;
  }
  /**
   * Upload a file to project storage
   * 
   * @param file - File, Blob, or Buffer to upload
   * @param path - Destination path within project storage (extension will be auto-corrected to match file type)
   * @param options - Upload options including upsert and progress callback
   * @returns Promise resolving to upload response with public URL
   * 
   * @example
   * ```ts
   * // Extension automatically corrected to match actual file type
   * const { publicUrl } = await blink.storage.upload(
   *   pngFile,
   *   `avatars/${user.id}`, // No extension needed!
   *   { upsert: true }
   * );
   * // If file is PNG, final path will be: avatars/user123.png
   * 
   * // Or with extension (will be corrected if wrong)
   * const { publicUrl } = await blink.storage.upload(
   *   pngFile,
   *   `avatars/${user.id}.jpg`, // Wrong extension
   *   { upsert: true }
   * );
   * // Final path will be: avatars/user123.png (auto-corrected!)
   * ```
   */
  async upload(file, path, options = {}) {
    try {
      if (!file) {
        throw new BlinkStorageError("File is required");
      }
      if (!path || typeof path !== "string" || !path.trim()) {
        throw new BlinkStorageError("Path must be a non-empty string");
      }
      const maxSize = 50 * 1024 * 1024;
      let fileSize = 0;
      if (file instanceof File || file instanceof Blob) {
        fileSize = file.size;
      } else if (typeof Buffer !== "undefined" && file instanceof Buffer) {
        fileSize = file.length;
      }
      if (fileSize > maxSize) {
        throw new BlinkStorageError(`File size (${Math.round(fileSize / 1024 / 1024)}MB) exceeds maximum allowed size (50MB)`);
      }
      const { correctedPath, detectedContentType } = await this.detectFileTypeAndCorrectPath(file, path);
      const response = await this.httpClient.uploadFile(
        `/api/storage/${this.httpClient.projectId}/upload`,
        file,
        correctedPath,
        // Use corrected path with proper extension
        {
          upsert: options.upsert,
          onProgress: options.onProgress,
          contentType: detectedContentType
          // Pass detected content type
        }
      );
      if (response.data?.data?.publicUrl) {
        return { publicUrl: response.data.data.publicUrl };
      } else if (response.data?.publicUrl) {
        return { publicUrl: response.data.publicUrl };
      } else {
        throw new BlinkStorageError("Invalid response format: missing publicUrl");
      }
    } catch (error) {
      if (error instanceof BlinkStorageError) {
        throw error;
      }
      if (error instanceof Error && "status" in error) {
        const status = error.status;
        if (status === 409) {
          throw new BlinkStorageError("File already exists. Set upsert: true to overwrite.", 409);
        }
        if (status === 400) {
          throw new BlinkStorageError("Invalid request parameters", 400);
        }
      }
      throw new BlinkStorageError(
        `Upload failed: ${error instanceof Error ? error.message : "Unknown error"}`,
        void 0,
        { originalError: error }
      );
    }
  }
  /**
   * Detect file type from actual file content and correct path extension
   * This ensures the path extension always matches the actual file type
   */
  async detectFileTypeAndCorrectPath(file, originalPath) {
    try {
      const fileSignature = await this.getFileSignature(file);
      const detectedType = this.detectFileTypeFromSignature(fileSignature);
      let detectedContentType = detectedType.mimeType;
      let detectedExtension = detectedType.extension;
      if (!detectedContentType && file instanceof File && file.type) {
        detectedContentType = file.type;
        detectedExtension = this.getExtensionFromMimeType(file.type);
      }
      if (!detectedContentType) {
        detectedContentType = "application/octet-stream";
        detectedExtension = "bin";
      }
      const pathParts = originalPath.split("/");
      const fileName = pathParts[pathParts.length - 1];
      const directory = pathParts.slice(0, -1).join("/");
      if (!fileName) {
        throw new Error("Invalid path: filename cannot be empty");
      }
      const nameWithoutExt = fileName.includes(".") ? fileName.substring(0, fileName.lastIndexOf(".")) : fileName;
      const correctedFileName = `${nameWithoutExt}.${detectedExtension}`;
      const correctedPath = directory ? `${directory}/${correctedFileName}` : correctedFileName;
      return {
        correctedPath,
        detectedContentType
      };
    } catch (error) {
      console.warn("File type detection failed, using original path:", error);
      return {
        correctedPath: originalPath,
        detectedContentType: "application/octet-stream"
      };
    }
  }
  /**
   * Get the first few bytes of a file to analyze its signature
   */
  async getFileSignature(file) {
    const bytesToRead = 12;
    if (typeof Buffer !== "undefined" && file instanceof Buffer) {
      return new Uint8Array(file.slice(0, bytesToRead));
    }
    if (file instanceof File || file instanceof Blob) {
      const slice = file.slice(0, bytesToRead);
      const arrayBuffer = await slice.arrayBuffer();
      return new Uint8Array(arrayBuffer);
    }
    throw new Error("Unsupported file type for signature detection");
  }
  /**
   * Detect file type from file signature (magic numbers)
   * This is the most reliable way to detect actual file type
   */
  detectFileTypeFromSignature(signature) {
    const hex = Array.from(signature).map((b) => b.toString(16).padStart(2, "0")).join("");
    const signatures = {
      // Images
      "ffd8ff": { mimeType: "image/jpeg", extension: "jpg" },
      "89504e47": { mimeType: "image/png", extension: "png" },
      "47494638": { mimeType: "image/gif", extension: "gif" },
      "52494646": { mimeType: "image/webp", extension: "webp" },
      // RIFF (WebP container)
      "424d": { mimeType: "image/bmp", extension: "bmp" },
      "49492a00": { mimeType: "image/tiff", extension: "tiff" },
      "4d4d002a": { mimeType: "image/tiff", extension: "tiff" },
      // Documents
      "25504446": { mimeType: "application/pdf", extension: "pdf" },
      "504b0304": { mimeType: "application/zip", extension: "zip" },
      // Also used by docx, xlsx
      "d0cf11e0": { mimeType: "application/msword", extension: "doc" },
      // Audio
      "494433": { mimeType: "audio/mpeg", extension: "mp3" },
      "664c6143": { mimeType: "audio/flac", extension: "flac" },
      "4f676753": { mimeType: "audio/ogg", extension: "ogg" },
      // Video
      "000000": { mimeType: "video/mp4", extension: "mp4" },
      // ftyp box
      "1a45dfa3": { mimeType: "video/webm", extension: "webm" },
      // Text
      "efbbbf": { mimeType: "text/plain", extension: "txt" }
      // UTF-8 BOM
    };
    for (const [sig, type] of Object.entries(signatures)) {
      if (hex.startsWith(sig)) {
        return type;
      }
    }
    if (hex.startsWith("52494646") && hex.substring(16, 24) === "57454250") {
      return { mimeType: "image/webp", extension: "webp" };
    }
    if (hex.substring(8, 16) === "66747970") {
      return { mimeType: "video/mp4", extension: "mp4" };
    }
    return { mimeType: "", extension: "" };
  }
  /**
   * Get file extension from MIME type as fallback
   */
  getExtensionFromMimeType(mimeType) {
    const mimeToExt = {
      "image/jpeg": "jpg",
      "image/png": "png",
      "image/gif": "gif",
      "image/webp": "webp",
      "image/bmp": "bmp",
      "image/svg+xml": "svg",
      "application/pdf": "pdf",
      "text/plain": "txt",
      "text/html": "html",
      "text/css": "css",
      "application/javascript": "js",
      "application/json": "json",
      "audio/mpeg": "mp3",
      "audio/wav": "wav",
      "audio/ogg": "ogg",
      "video/mp4": "mp4",
      "video/webm": "webm",
      "application/zip": "zip"
    };
    return mimeToExt[mimeType] || "bin";
  }
  /**
   * Get a download URL for a file that triggers browser download
   * 
   * @param path - Path to the file in project storage
   * @param options - Download options including custom filename
   * @returns Promise resolving to download response with download URL
   * 
   * @example
   * ```ts
   * // Download with original filename
   * const { downloadUrl, filename } = await blink.storage.download('images/photo.jpg');
   * window.open(downloadUrl, '_blank');
   * 
   * // Download with custom filename
   * const { downloadUrl } = await blink.storage.download(
   *   'images/photo.jpg',
   *   { filename: 'my-photo.jpg' }
   * );
   * 
   * // Create download link in React
   * <a href={downloadUrl} download={filename}>Download Image</a>
   * ```
   */
  async download(path, options = {}) {
    try {
      if (!path || typeof path !== "string" || !path.trim()) {
        throw new BlinkStorageError("Path must be a non-empty string");
      }
      const response = await this.httpClient.request(
        `/api/storage/${this.httpClient.projectId}/download`,
        {
          method: "GET",
          searchParams: {
            path: path.trim(),
            ...options.filename && { filename: options.filename }
          }
        }
      );
      if (response.data?.downloadUrl) {
        return {
          downloadUrl: response.data.downloadUrl,
          filename: response.data.filename || options.filename || path.split("/").pop() || "download",
          contentType: response.data.contentType,
          size: response.data.size
        };
      } else {
        throw new BlinkStorageError("Invalid response format: missing downloadUrl");
      }
    } catch (error) {
      if (error instanceof BlinkStorageError) {
        throw error;
      }
      if (error instanceof Error && "status" in error) {
        const status = error.status;
        if (status === 404) {
          throw new BlinkStorageError("File not found", 404);
        }
        if (status === 400) {
          throw new BlinkStorageError("Invalid request parameters", 400);
        }
      }
      throw new BlinkStorageError(
        `Download failed: ${error instanceof Error ? error.message : "Unknown error"}`,
        void 0,
        { originalError: error }
      );
    }
  }
  /**
   * Remove one or more files from project storage
   * 
   * @param paths - File paths to remove
   * @returns Promise that resolves when files are removed
   * 
   * @example
   * ```ts
   * await blink.storage.remove('avatars/user1.png');
   * await blink.storage.remove('file1.pdf', 'file2.pdf', 'file3.pdf');
   * ```
   */
  async remove(...paths) {
    try {
      if (paths.length === 0) {
        throw new BlinkStorageError("At least one path must be provided");
      }
      for (const path of paths) {
        if (!path || typeof path !== "string") {
          throw new BlinkStorageError("All paths must be non-empty strings");
        }
      }
      await this.httpClient.request(
        `/api/storage/${this.httpClient.projectId}/remove`,
        {
          method: "DELETE",
          body: { paths },
          headers: { "Content-Type": "application/json" }
        }
      );
    } catch (error) {
      if (error instanceof BlinkStorageError) {
        throw error;
      }
      if (error instanceof Error && "status" in error) {
        const status = error.status;
        if (status === 400) {
          throw new BlinkStorageError("Invalid request parameters", 400);
        }
      }
      throw new BlinkStorageError(
        `Failed to remove files: ${error instanceof Error ? error.message : "Unknown error"}`,
        void 0,
        { originalError: error }
      );
    }
  }
};

// src/ai.ts
var BlinkAIImpl = class {
  constructor(httpClient) {
    this.httpClient = httpClient;
  }
  // Supported image formats for validation
  SUPPORTED_IMAGE_FORMATS = ["jpg", "jpeg", "png", "gif", "webp"];
  /**
   * Validates if a URL is a valid HTTPS image URL
   */
  validateImageUrl(url) {
    try {
      const parsedUrl = new URL(url);
      if (parsedUrl.protocol !== "https:") {
        return { isValid: false, error: "Image URLs must use HTTPS protocol" };
      }
      const pathname = parsedUrl.pathname.toLowerCase();
      const hasValidExtension = this.SUPPORTED_IMAGE_FORMATS.some(
        (format) => pathname.endsWith(`.${format}`)
      );
      if (!hasValidExtension) {
        return {
          isValid: false,
          error: `Image URL must end with a supported format: ${this.SUPPORTED_IMAGE_FORMATS.join(", ")}`
        };
      }
      return { isValid: true };
    } catch (error) {
      return { isValid: false, error: "Invalid URL format" };
    }
  }
  /**
   * Validates messages for image content
   */
  validateMessages(messages) {
    const errors = [];
    messages.forEach((message, messageIndex) => {
      if (Array.isArray(message.content)) {
        message.content.forEach((item, contentIndex) => {
          if (item.type === "image") {
            if (!item.image || typeof item.image !== "string") {
              errors.push(`Message ${messageIndex}, content ${contentIndex}: Image content must have a valid image URL`);
            } else {
              const validation = this.validateImageUrl(item.image);
              if (!validation.isValid) {
                errors.push(`Message ${messageIndex}, content ${contentIndex}: ${validation.error}`);
              }
            }
          }
        });
      }
    });
    return { isValid: errors.length === 0, errors };
  }
  /**
   * Get MIME type for audio format
   */
  getMimeTypeForFormat(format) {
    const mimeTypes = {
      mp3: "audio/mpeg",
      opus: "audio/opus",
      aac: "audio/aac",
      flac: "audio/flac",
      wav: "audio/wav",
      pcm: "audio/pcm"
    };
    return mimeTypes[format] || "audio/mpeg";
  }
  /**
   * Generates a text response using the Blink AI engine.
   * 
   * @param options - An object containing either:
   *   - `prompt`: a simple string prompt
   *   - OR `messages`: an array of chat messages for conversation
   *   - Plus optional model, search, maxSteps, experimental_continueSteps, maxTokens, temperature, signal parameters
   * 
   * @example
   * ```ts
   * // Simple prompt
   * const { text } = await blink.ai.generateText({ 
   *   prompt: "Write a poem about coding" 
   * });
   * 
   * // Chat messages (text only)
   * const { text } = await blink.ai.generateText({
   *   messages: [
   *     { role: "system", content: "You are a helpful assistant" },
   *     { role: "user", content: "Explain quantum computing" }
   *   ]
   * });
   * 
   * // With image content
   * const { text } = await blink.ai.generateText({
   *   messages: [
   *     { 
   *       role: "user", 
   *       content: [
   *         { type: "text", text: "What do you see in this image?" },
   *         { type: "image", image: "https://example.com/photo.jpg" }
   *       ]
   *     }
   *   ]
   * });
   * 
   * // Mixed content with multiple images
   * const { text } = await blink.ai.generateText({
   *   messages: [
   *     { 
   *       role: "user", 
   *       content: [
   *         { type: "text", text: "Compare these two images:" },
   *         { type: "image", image: "https://example.com/image1.jpg" },
   *         { type: "image", image: "https://example.com/image2.jpg" }
   *       ]
   *     }
   *   ]
   * });
   * 
   * // With options
   * const { text, usage } = await blink.ai.generateText({
   *   prompt: "Summarize this article",
   *   model: "gpt-4o-mini",
   *   maxTokens: 150,
   *   temperature: 0.7
   * });
   * 
   * // With web search (OpenAI models only)
   * const { text, sources } = await blink.ai.generateText({
   *   prompt: "What are the latest developments in AI?",
   *   model: "gpt-4o-mini",
   *   search: true // Enables web search
   * });
   * 
   * // With advanced multi-step configuration
   * const { text } = await blink.ai.generateText({
   *   prompt: "Research and analyze recent tech trends",
   *   model: "gpt-4o",
   *   search: true,
   *   maxSteps: 10, // Allow up to 10 reasoning steps
   *   experimental_continueSteps: true // Enable continued reasoning
   * });
   * ```
   * 
   * @returns Promise<TextGenerationResponse> - Object containing:
   *   - `text`: Generated text string
   *   - `usage`: Token usage information
   *   - `finishReason`: Why generation stopped ("stop", "length", etc.)
   */
  async generateText(options) {
    try {
      if (!options.prompt && !options.messages) {
        throw new BlinkAIError("Either prompt or messages is required");
      }
      if (options.messages) {
        const validation = this.validateMessages(options.messages);
        if (!validation.isValid) {
          throw new BlinkAIError(`Message validation failed: ${validation.errors.join("; ")}`);
        }
      }
      const requestBody = {
        model: options.model,
        stream: false,
        search: options.search,
        maxSteps: options.maxSteps,
        experimental_continueSteps: options.experimental_continueSteps,
        maxTokens: options.maxTokens,
        temperature: options.temperature,
        signal: options.signal
      };
      if (options.prompt) {
        requestBody.prompt = options.prompt;
      }
      if (options.messages) {
        requestBody.messages = options.messages;
      }
      const response = await this.httpClient.aiText(
        options.prompt || "",
        requestBody
      );
      if (response.data?.result) {
        return response.data.result;
      } else if (response.data?.text) {
        return response.data;
      } else {
        throw new BlinkAIError("Invalid response format: missing text");
      }
    } catch (error) {
      if (error instanceof BlinkAIError) {
        throw error;
      }
      throw new BlinkAIError(
        `Text generation failed: ${error instanceof Error ? error.message : "Unknown error"}`,
        void 0,
        { originalError: error }
      );
    }
  }
  /**
   * Streams text generation with real-time updates as the AI generates content.
   * 
   * @param options - Same as generateText: either `prompt` or `messages` with optional parameters including search, maxSteps, experimental_continueSteps
   * @param onChunk - Callback function that receives each text chunk as it's generated
   * 
   * @example
   * ```ts
   * // Stream with prompt
   * await blink.ai.streamText(
   *   { prompt: "Write a short story about space exploration" },
   *   (chunk) => {
   *     process.stdout.write(chunk); // Real-time output
   *   }
   * );
   * 
   * // Stream with messages
   * await blink.ai.streamText(
   *   { 
   *     messages: [
   *       { role: "system", content: "You are a creative writer" },
   *       { role: "user", content: "Write a haiku about programming" }
   *     ]
   *   },
   *   (chunk) => updateUI(chunk)
   * );
   * ```
   * 
   * @returns Promise<TextGenerationResponse> - Final complete response with full text and metadata
   */
  async streamText(options, onChunk) {
    try {
      if (!options.prompt && !options.messages) {
        throw new BlinkAIError("Either prompt or messages is required");
      }
      if (options.messages) {
        const validation = this.validateMessages(options.messages);
        if (!validation.isValid) {
          throw new BlinkAIError(`Message validation failed: ${validation.errors.join("; ")}`);
        }
      }
      const result = await this.httpClient.streamAiText(
        options.prompt || "",
        {
          model: options.model,
          messages: options.messages,
          search: options.search,
          maxSteps: options.maxSteps,
          experimental_continueSteps: options.experimental_continueSteps,
          maxTokens: options.maxTokens,
          temperature: options.temperature,
          signal: options.signal
        },
        onChunk
      );
      return {
        text: result.text || "",
        finishReason: "stop",
        usage: result.usage,
        ...result
      };
    } catch (error) {
      if (error instanceof BlinkAIError) {
        throw error;
      }
      throw new BlinkAIError(
        `Text streaming failed: ${error instanceof Error ? error.message : "Unknown error"}`,
        void 0,
        { originalError: error }
      );
    }
  }
  /**
   * Generates structured JSON objects using AI with schema validation.
   * 
   * @param options - Object containing:
   *   - `prompt`: Description of what object to generate (required)
   *   - `schema`: JSON Schema to validate the generated object
   *   - `output`: Type of output ("object", "array", "enum")
   *   - `enum`: Array of allowed values for enum output
   *   - Plus optional model, signal parameters
   * 
   * @example
   * ```ts
   * // Generate user profile
   * const { object } = await blink.ai.generateObject({
   *   prompt: "Generate a user profile for a software developer",
   *   schema: {
   *     type: "object",
   *     properties: {
   *       name: { type: "string" },
   *       age: { type: "number" },
   *       skills: { type: "array", items: { type: "string" } },
   *       experience: { type: "number" }
   *     },
   *     required: ["name", "skills"]
   *   }
   * });
   * 
   * // Generate array of items
   * const { object } = await blink.ai.generateObject({
   *   prompt: "List 5 programming languages",
   *   output: "array",
   *   schema: {
   *     type: "array",
   *     items: { type: "string" }
   *   }
   * });
   * 
   * // Generate enum value
   * const { object } = await blink.ai.generateObject({
   *   prompt: "Choose the best programming language for web development",
   *   output: "enum",
   *   enum: ["JavaScript", "Python", "TypeScript", "Go"]
   * });
   * ```
   * 
   * @returns Promise<ObjectGenerationResponse> - Object containing:
   *   - `object`: The generated and validated JSON object/array/enum
   *   - `usage`: Token usage information
   *   - `finishReason`: Why generation stopped
   */
  async generateObject(options) {
    try {
      if (!options.prompt) {
        throw new BlinkAIError("Prompt is required");
      }
      const response = await this.httpClient.aiObject(
        options.prompt,
        {
          model: options.model,
          output: options.output,
          schema: options.schema,
          enum: options.enum,
          stream: false,
          signal: options.signal
        }
      );
      if (response.data?.result) {
        return response.data.result;
      } else if (response.data?.object) {
        return response.data;
      } else {
        throw new BlinkAIError("Invalid response format: missing object");
      }
    } catch (error) {
      if (error instanceof BlinkAIError) {
        throw error;
      }
      throw new BlinkAIError(
        `Object generation failed: ${error instanceof Error ? error.message : "Unknown error"}`,
        void 0,
        { originalError: error }
      );
    }
  }
  /**
   * Streams structured object generation with real-time partial updates as the AI builds the object.
   * 
   * @param options - Same as generateObject: prompt, schema, output type, etc.
   * @param onPartial - Callback function that receives partial object updates as they're generated
   * 
   * @example
   * ```ts
   * // Stream object generation with schema
   * await blink.ai.streamObject(
   *   {
   *     prompt: "Generate a detailed product catalog entry",
   *     schema: {
   *       type: "object",
   *       properties: {
   *         name: { type: "string" },
   *         price: { type: "number" },
   *         description: { type: "string" },
   *         features: { type: "array", items: { type: "string" } }
   *       }
   *     }
   *   },
   *   (partial) => {
   *     console.log("Partial update:", partial);
   *     updateProductForm(partial); // Update UI in real-time
   *   }
   * );
   * ```
   * 
   * @returns Promise<ObjectGenerationResponse> - Final complete object with metadata
   */
  async streamObject(options, onPartial) {
    try {
      if (!options.prompt) {
        throw new BlinkAIError("Prompt is required");
      }
      const result = await this.httpClient.streamAiObject(
        options.prompt,
        {
          model: options.model,
          output: options.output,
          schema: options.schema,
          enum: options.enum,
          signal: options.signal
        },
        onPartial
      );
      return {
        object: result.object || {},
        finishReason: "stop",
        usage: result.usage,
        ...result
      };
    } catch (error) {
      if (error instanceof BlinkAIError) {
        throw error;
      }
      throw new BlinkAIError(
        `Object streaming failed: ${error instanceof Error ? error.message : "Unknown error"}`,
        void 0,
        { originalError: error }
      );
    }
  }
  /**
    * Generates images from text descriptions using AI.
    * 
    * @param options - Object containing:
    *   - `prompt`: Text description of the desired image (required)
    *   - `size`: Image dimensions (default: "1024x1024")
    *   - `quality`: Image quality ("auto", "low", "medium", or "high", default: "auto")
    *   - `n`: Number of images to generate (default: 1)
    *   - `background`: Background handling ("auto", "transparent", "opaque", default: "auto")
    *   - Plus optional signal parameter
    * 
    * @example
    * ```ts
    * // Basic image generation
    * const { data } = await blink.ai.generateImage({
    *   prompt: "A serene landscape with mountains and a lake at sunset"
    * });
    * console.log("Image URL:", data[0].url);
    * 
     * // High-quality image with specific size
  * const { data } = await blink.ai.generateImage({
  *   prompt: "A futuristic city skyline with flying cars",
  *   size: "1536x1024",
  *   quality: "high",
  *   background: "transparent"
  * });
    * 
     * // Multiple images
  * const { data } = await blink.ai.generateImage({
  *   prompt: "A cute robot mascot for a tech company",
  *   n: 3,
  *   size: "1024x1024",
  *   quality: "high"
  * });
    * data.forEach((img, i) => console.log(`Image ${i+1}:`, img.url));
    * ```
    * 
    * @returns Promise<ImageGenerationResponse> - Object containing:
    *   - `data`: Array of generated images with URLs
    *   - `created`: Timestamp of generation
    *   - `usage`: Token usage information
    */
  async generateImage(options) {
    try {
      if (!options.prompt) {
        throw new BlinkAIError("Prompt is required");
      }
      const response = await this.httpClient.aiImage(
        options.prompt,
        {
          model: "gpt-image-1",
          size: options.size,
          quality: options.quality,
          n: options.n,
          background: options.background,
          response_format: "url",
          signal: options.signal
        }
      );
      let imageResponse;
      if (response.data?.result?.data) {
        imageResponse = response.data.result;
      } else if (response.data?.data) {
        imageResponse = response.data;
      } else {
        throw new BlinkAIError("Invalid response format: missing image data");
      }
      if (!Array.isArray(imageResponse.data)) {
        throw new BlinkAIError("Invalid response format: data should be an array");
      }
      imageResponse.data = imageResponse.data.map((item) => {
        if (typeof item === "string") {
          return { url: item };
        } else if (item.url) {
          return item;
        } else {
          throw new BlinkAIError("Invalid image response format");
        }
      });
      return imageResponse;
    } catch (error) {
      if (error instanceof BlinkAIError) {
        throw error;
      }
      throw new BlinkAIError(
        `Image generation failed: ${error instanceof Error ? error.message : "Unknown error"}`,
        void 0,
        { originalError: error }
      );
    }
  }
  /**
    * Modifies existing images using AI with text prompts for image-to-image editing.
    * 
    * @param options - Object containing:
    *   - `images`: Array of public image URLs to modify (required, up to 16 images)
    *   - `prompt`: Text description of desired modifications (required)
    *   - `size`: Output image dimensions (default: "auto")
    *   - `quality`: Image quality ("auto", "low", "medium", or "high", default: "auto")
    *   - `n`: Number of output images to generate (default: 1)
    *   - `background`: Background handling ("auto", "transparent", "opaque", default: "auto")
    *   - Plus optional signal parameter
    * 
    * @example
    * ```ts
    * // Professional headshots from casual photos
    * const { data } = await blink.ai.modifyImage({
    *   images: [
    *     "https://storage.example.com/user-photo-1.jpg",
    *     "https://storage.example.com/user-photo-2.jpg"
    *   ],
     *   prompt: "Transform into professional business headshots with studio lighting",
  *   quality: "high",
  *   n: 4
    * });
    * data.forEach((img, i) => console.log(`Headshot ${i+1}:`, img.url));
    * 
    * // Artistic style transformation
     * const { data } = await blink.ai.modifyImage({
  *   images: ["https://storage.example.com/portrait.jpg"],
  *   prompt: "Transform into oil painting style with dramatic lighting",
  *   quality: "high",
  *   size: "1024x1024"
  * });
    * 
    * // Background replacement
    * const { data } = await blink.ai.modifyImage({
    *   images: ["https://storage.example.com/product.jpg"],
    *   prompt: "Remove background and place on clean white studio background",
    *   background: "transparent",
    *   n: 2
    * });
    * 
    * // Batch processing multiple photos
    * const userPhotos = [
    *   "https://storage.example.com/photo1.jpg",
    *   "https://storage.example.com/photo2.jpg",
    *   "https://storage.example.com/photo3.jpg"
    * ];
    * const { data } = await blink.ai.modifyImage({
     *   images: userPhotos,
  *   prompt: "Convert to black and white vintage style photographs",
  *   quality: "high"
    * });
    * ```
    * 
    * @returns Promise<ImageGenerationResponse> - Object containing:
    *   - `data`: Array of modified images with URLs
    *   - `created`: Timestamp of generation
    *   - `usage`: Token usage information
    */
  async modifyImage(options) {
    try {
      if (!options.prompt) {
        throw new BlinkAIError("Prompt is required");
      }
      if (!options.images || !Array.isArray(options.images) || options.images.length === 0) {
        throw new BlinkAIError("Images array is required and must contain at least one image URL");
      }
      if (options.images.length > 16) {
        throw new BlinkAIError("Maximum 16 images allowed");
      }
      for (let i = 0; i < options.images.length; i++) {
        const validation = this.validateImageUrl(options.images[i]);
        if (!validation.isValid) {
          throw new BlinkAIError(`Image ${i + 1}: ${validation.error}`);
        }
      }
      const response = await this.httpClient.aiImage(
        options.prompt,
        // Non-null assertion since we validated above
        {
          model: "gpt-image-1",
          images: options.images,
          size: options.size,
          quality: options.quality,
          n: options.n,
          background: options.background,
          response_format: "url",
          signal: options.signal
        }
      );
      let imageResponse;
      if (response.data?.result?.data) {
        imageResponse = response.data.result;
      } else if (response.data?.data) {
        imageResponse = response.data;
      } else {
        throw new BlinkAIError("Invalid response format: missing image data");
      }
      if (!Array.isArray(imageResponse.data)) {
        throw new BlinkAIError("Invalid response format: data should be an array");
      }
      imageResponse.data = imageResponse.data.map((item) => {
        if (typeof item === "string") {
          return { url: item };
        } else if (item.url) {
          return item;
        } else {
          throw new BlinkAIError("Invalid image response format");
        }
      });
      return imageResponse;
    } catch (error) {
      if (error instanceof BlinkAIError) {
        throw error;
      }
      throw new BlinkAIError(
        `Image modification failed: ${error instanceof Error ? error.message : "Unknown error"}`,
        void 0,
        { originalError: error }
      );
    }
  }
  /**
   * Converts text to speech using AI voice synthesis models.
   * 
   * @param options - Object containing:
   *   - `text`: Text content to convert to speech (required)
   *   - `voice`: Voice to use ("alloy", "echo", "fable", "onyx", "nova", "shimmer")
   *   - `response_format`: Audio format ("mp3", "opus", "aac", "flac", "wav", "pcm")
   *   - `speed`: Speech speed (0.25 to 4.0, default: 1.0)
   *   - Plus optional model, signal parameters
   * 
   * @example
   * ```ts
   * // Basic text-to-speech
   * const { url } = await blink.ai.generateSpeech({
   *   text: "Hello, welcome to our AI-powered application!"
   * });
   * console.log("Audio URL:", url);
   * 
   * // Custom voice and format
   * const { url, voice, format } = await blink.ai.generateSpeech({
   *   text: "This is a demonstration of our speech synthesis capabilities.",
   *   voice: "nova",
   *   response_format: "wav",
   *   speed: 1.2
   * });
   * console.log(`Generated ${format} audio with ${voice} voice:`, url);
   * 
   * // Slow, clear speech for accessibility
   * const { url } = await blink.ai.generateSpeech({
   *   text: "Please listen carefully to these important instructions.",
   *   voice: "echo",
   *   speed: 0.8
   * });
   * ```
   * 
   * @returns Promise<SpeechGenerationResponse> - Object containing:
   *   - `url`: URL to the generated audio file
   *   - `voice`: Voice used for generation
   *   - `format`: Audio format
   *   - `mimeType`: MIME type of the audio
   */
  async generateSpeech(options) {
    try {
      if (!options.text) {
        throw new BlinkAIError("Text is required");
      }
      const response = await this.httpClient.aiSpeech(
        options.text,
        {
          model: options.model,
          voice: options.voice,
          response_format: options.response_format,
          speed: options.speed,
          signal: options.signal
        }
      );
      let speechResponse;
      if (response.data?.result) {
        speechResponse = response.data.result;
      } else if (response.data?.url) {
        speechResponse = response.data;
      } else {
        throw new BlinkAIError("Invalid response format: missing speech data");
      }
      if (!speechResponse.url) {
        if (typeof response.data === "string") {
          speechResponse = {
            url: response.data,
            voice: options.voice || "alloy",
            format: options.response_format || "mp3",
            mimeType: this.getMimeTypeForFormat(options.response_format || "mp3")
          };
        } else if (response.data?.data) {
          speechResponse = {
            url: response.data.data,
            voice: options.voice || "alloy",
            format: options.response_format || "mp3",
            mimeType: this.getMimeTypeForFormat(options.response_format || "mp3")
          };
        } else {
          throw new BlinkAIError("Invalid response format: no audio URL found");
        }
      }
      if (!speechResponse.voice) {
        speechResponse.voice = options.voice || "alloy";
      }
      if (!speechResponse.format) {
        speechResponse.format = options.response_format || "mp3";
      }
      if (!speechResponse.mimeType) {
        speechResponse.mimeType = this.getMimeTypeForFormat(speechResponse.format);
      }
      return speechResponse;
    } catch (error) {
      if (error instanceof BlinkAIError) {
        throw error;
      }
      throw new BlinkAIError(
        `Speech generation failed: ${error instanceof Error ? error.message : "Unknown error"}`,
        void 0,
        { originalError: error }
      );
    }
  }
  /**
   * Transcribes audio content to text using AI speech recognition models.
   * 
   * @param options - Object containing:
   *   - `audio`: Audio input as URL string, base64 string, or number array buffer (required)
   *   - `language`: Language code for transcription (e.g., "en", "es", "fr")
   *   - `response_format`: Output format ("json", "text", "srt", "verbose_json", "vtt")
   *   - Plus optional model, signal parameters
   * 
   * @example
   * ```ts
   * // Transcribe from URL
   * const { text } = await blink.ai.transcribeAudio({
   *   audio: "https://example.com/meeting-recording.mp3"
   * });
   * console.log("Transcription:", text);
   * 
   * // Transcribe with language hint
   * const { text, language } = await blink.ai.transcribeAudio({
   *   audio: "https://example.com/spanish-audio.wav",
   *   language: "es"
   * });
   * console.log(`Transcribed ${language}:`, text);
   * 
   * // Transcribe with timestamps (verbose format)
   * const result = await blink.ai.transcribeAudio({
   *   audio: audioFileUrl,
   *   response_format: "verbose_json"
   * });
   * result.segments?.forEach(segment => {
   *   console.log(`${segment.start}s - ${segment.end}s: ${segment.text}`);
   * });
   * 
   * // Transcribe from audio buffer
   * const audioBuffer = new Array(1024).fill(0); // Your audio data
   * const { text } = await blink.ai.transcribeAudio({
   *   audio: audioBuffer,
   *   language: "en"
   * });
   * ```
   * 
   * @returns Promise<TranscriptionResponse> - Object containing:
   *   - `text`: Transcribed text content
   *   - `transcript`: Alias for text
   *   - `segments`: Array of timestamped segments (if verbose format)
   *   - `language`: Detected language
   *   - `duration`: Audio duration in seconds
   */
  async transcribeAudio(options) {
    try {
      if (!options.audio) {
        throw new BlinkAIError("Audio is required");
      }
      const response = await this.httpClient.aiTranscribe(
        options.audio,
        {
          model: options.model,
          language: options.language,
          response_format: options.response_format,
          signal: options.signal
        }
      );
      if (response.data?.result) {
        return response.data.result;
      } else if (response.data?.text || response.data?.transcript) {
        return {
          text: response.data.text || response.data.transcript,
          transcript: response.data.transcript || response.data.text,
          ...response.data
        };
      } else {
        throw new BlinkAIError("Invalid response format: missing transcription text");
      }
    } catch (error) {
      if (error instanceof BlinkAIError) {
        throw error;
      }
      throw new BlinkAIError(
        `Audio transcription failed: ${error instanceof Error ? error.message : "Unknown error"}`,
        void 0,
        { originalError: error }
      );
    }
  }
};

// src/data.ts
var BlinkDataImpl = class {
  constructor(httpClient, projectId) {
    this.httpClient = httpClient;
    this.projectId = projectId;
  }
  async extractFromUrl(url, options = {}) {
    const { chunking = false, chunkSize } = options;
    const request = { url, chunking, chunkSize };
    const response = await this.httpClient.dataExtractFromUrl(this.projectId, request);
    return chunking ? response.data.chunks : response.data.text;
  }
  async extractFromBlob(file, options = {}) {
    const { chunking = false, chunkSize } = options;
    const response = await this.httpClient.dataExtractFromBlob(this.projectId, file, chunking, chunkSize);
    return chunking ? response.data.chunks : response.data.text;
  }
  async scrape(url) {
    const request = {
      url,
      formats: ["markdown", "html", "links", "extract", "metadata"]
    };
    const response = await this.httpClient.dataScrape(this.projectId, request);
    const data = response.data;
    return {
      markdown: data.markdown || "",
      html: data.html || "",
      metadata: {
        title: data.metadata?.title || "",
        description: data.metadata?.description || "",
        url: data.metadata?.url || url,
        domain: data.metadata?.domain || new URL(url).hostname,
        favicon: data.metadata?.favicon,
        image: data.metadata?.image,
        author: data.metadata?.author,
        publishedTime: data.metadata?.publishedTime,
        modifiedTime: data.metadata?.modifiedTime,
        type: data.metadata?.type,
        siteName: data.metadata?.siteName,
        locale: data.metadata?.locale,
        keywords: data.metadata?.keywords || []
      },
      links: data.links || [],
      extract: {
        title: data.extract?.title || data.metadata?.title || "",
        description: data.extract?.description || data.metadata?.description || "",
        headings: data.extract?.headings || [],
        text: data.extract?.text || data.markdown || ""
      }
    };
  }
  async screenshot(url, options = {}) {
    const request = { url, ...options };
    const response = await this.httpClient.dataScreenshot(this.projectId, request);
    return response.data.url;
  }
  async fetch(request) {
    const response = await this.httpClient.dataFetch(this.projectId, request);
    if ("status" in response.data && "headers" in response.data) {
      return response.data;
    }
    throw new BlinkDataError("Unexpected response format from fetch endpoint");
  }
  async fetchAsync(request) {
    const asyncRequest = { ...request, async: true };
    const response = await this.httpClient.dataFetch(this.projectId, asyncRequest);
    if ("status" in response.data && response.data.status === "triggered") {
      return response.data;
    }
    throw new BlinkDataError("Unexpected response format from async fetch endpoint");
  }
  async search(query, options) {
    const normalizeType = (type) => {
      switch (type) {
        case "news":
          return "nws";
        case "images":
        case "image":
          return "isch";
        case "videos":
        case "video":
          return "vid";
        case "shopping":
        case "shop":
          return "shop";
        default:
          return void 0;
      }
    };
    const request = {
      q: query,
      location: options?.location,
      hl: options?.language || "en",
      tbm: normalizeType(options?.type),
      num: options?.limit
    };
    const response = await this.httpClient.dataSearch(this.projectId, request);
    return response.data;
  }
};

// src/realtime.ts
var getWebSocketClass = () => {
  if (typeof WebSocket !== "undefined") {
    return WebSocket;
  }
  try {
    const WS = __require("ws");
    return WS;
  } catch (error) {
    throw new BlinkRealtimeError('WebSocket is not available. Install "ws" package for Node.js environments.');
  }
};
var BlinkRealtimeChannel = class {
  constructor(channelName, httpClient, projectId) {
    this.channelName = channelName;
    this.httpClient = httpClient;
    this.projectId = projectId;
  }
  messageCallbacks = [];
  presenceCallbacks = [];
  websocket = null;
  isSubscribed = false;
  isConnected = false;
  isConnecting = false;
  reconnectTimer = null;
  heartbeatTimer = null;
  reconnectAttempts = 0;
  // Message queuing for when socket is not ready
  messageQueue = [];
  pendingSubscription = null;
  // Connection promise for awaiting readiness
  connectionPromise = null;
  /**
   * Check if channel is ready for publishing
   */
  isReady() {
    return this.isConnected && this.isSubscribed;
  }
  async subscribe(options = {}) {
    if (this.isSubscribed) {
      return;
    }
    await this.ensureConnected();
    return new Promise((resolve, reject) => {
      if (this.pendingSubscription) {
        clearTimeout(this.pendingSubscription.timeout);
        this.pendingSubscription.reject(new BlinkRealtimeError("Subscription cancelled by new subscription request"));
      }
      const timeout = setTimeout(() => {
        this.pendingSubscription = null;
        reject(new BlinkRealtimeError("Subscription timeout - no acknowledgment from server"));
      }, 1e4);
      this.pendingSubscription = {
        options,
        resolve: () => {
          clearTimeout(timeout);
          this.pendingSubscription = null;
          this.isSubscribed = true;
          this.startHeartbeat();
          resolve();
        },
        reject: (error) => {
          clearTimeout(timeout);
          this.pendingSubscription = null;
          reject(error);
        },
        timeout
      };
      const subscribeMessage = {
        type: "subscribe",
        payload: {
          channel: this.channelName,
          userId: options.userId,
          metadata: options.metadata
        }
      };
      this.sendMessage(JSON.stringify(subscribeMessage)).catch((error) => {
        if (this.pendingSubscription) {
          this.pendingSubscription.reject(error);
        }
      });
    });
  }
  async unsubscribe() {
    if (!this.isSubscribed) {
      return;
    }
    if (this.pendingSubscription) {
      clearTimeout(this.pendingSubscription.timeout);
      this.pendingSubscription.reject(new BlinkRealtimeError("Subscription cancelled by unsubscribe"));
      this.pendingSubscription = null;
    }
    if (this.websocket && this.websocket.readyState === 1) {
      const unsubscribeMessage = {
        type: "unsubscribe",
        payload: {
          channel: this.channelName
        }
      };
      this.websocket.send(JSON.stringify(unsubscribeMessage));
    }
    this.cleanup();
  }
  async publish(type, data, options = {}) {
    await this.ensureConnected();
    const publishMessage = {
      type: "publish",
      payload: {
        channel: this.channelName,
        type,
        data,
        userId: options.userId,
        metadata: options.metadata
      }
    };
    return this.sendMessage(JSON.stringify(publishMessage));
  }
  onMessage(callback) {
    this.messageCallbacks.push(callback);
    return () => {
      const index = this.messageCallbacks.indexOf(callback);
      if (index > -1) {
        this.messageCallbacks.splice(index, 1);
      }
    };
  }
  onPresence(callback) {
    this.presenceCallbacks.push(callback);
    return () => {
      const index = this.presenceCallbacks.indexOf(callback);
      if (index > -1) {
        this.presenceCallbacks.splice(index, 1);
      }
    };
  }
  async getPresence() {
    try {
      const response = await this.httpClient.realtimeGetPresence(this.projectId, this.channelName);
      return response.data.users || [];
    } catch (error) {
      throw new BlinkRealtimeError(
        `Failed to get presence for channel ${this.channelName}: ${error instanceof Error ? error.message : "Unknown error"}`
      );
    }
  }
  async getMessages(options = {}) {
    try {
      const response = await this.httpClient.realtimeGetMessages(this.projectId, {
        channel: this.channelName,
        limit: options.limit,
        start: options.after || "-",
        // after = start from this ID onwards, default to oldest
        end: options.before || "+"
        // before = end at this ID, default to newest
      });
      return response.data.messages || [];
    } catch (error) {
      throw new BlinkRealtimeError(
        `Failed to get messages for channel ${this.channelName}: ${error instanceof Error ? error.message : "Unknown error"}`
      );
    }
  }
  /**
   * Ensure WebSocket connection is established and ready
   */
  async ensureConnected() {
    if (this.isConnected && this.websocket?.readyState === 1) {
      return;
    }
    if (this.connectionPromise) {
      return this.connectionPromise;
    }
    this.connectionPromise = this.connectWebSocket();
    try {
      await this.connectionPromise;
    } finally {
      this.connectionPromise = null;
    }
  }
  /**
   * Send a message, queuing if socket not ready
   */
  sendMessage(message) {
    return new Promise((resolve, reject) => {
      let messageObj;
      try {
        messageObj = JSON.parse(message);
      } catch (error) {
        reject(new BlinkRealtimeError("Invalid message format"));
        return;
      }
      const timeout = setTimeout(() => {
        const index = this.messageQueue.findIndex((q) => q.resolve === resolve);
        if (index > -1) {
          this.messageQueue.splice(index, 1);
        }
        reject(new BlinkRealtimeError("Message send timeout - no response from server"));
      }, 1e4);
      const queuedMessage = {
        message,
        resolve,
        reject,
        timeout
      };
      if (this.websocket && this.websocket.readyState === 1) {
        if (messageObj.type === "publish") {
          this.sendQueuedMessage(queuedMessage);
        } else {
          this.websocket.send(message);
          clearTimeout(timeout);
          resolve("sent");
        }
      } else {
        this.messageQueue.push(queuedMessage);
      }
    });
  }
  /**
   * Send a queued message and set up response handling
   */
  sendQueuedMessage(queuedMessage) {
    const { message, resolve, reject, timeout } = queuedMessage;
    const handleResponse = (event) => {
      try {
        const response = JSON.parse(event.data);
        if (response.type === "published" && response.payload.channel === this.channelName) {
          clearTimeout(timeout);
          this.websocket.removeEventListener("message", handleResponse);
          resolve(response.payload.messageId);
        } else if (response.type === "error") {
          clearTimeout(timeout);
          this.websocket.removeEventListener("message", handleResponse);
          reject(new BlinkRealtimeError(`Server error: ${response.payload.error}`));
        }
      } catch (err) {
      }
    };
    const originalTimeout = timeout;
    const cleanupTimeout = setTimeout(() => {
      if (this.websocket) {
        this.websocket.removeEventListener("message", handleResponse);
      }
      reject(new BlinkRealtimeError("Message send timeout - no response from server"));
    }, 1e4);
    queuedMessage.timeout = cleanupTimeout;
    clearTimeout(originalTimeout);
    this.websocket.addEventListener("message", handleResponse);
    this.websocket.send(message);
  }
  /**
   * Flush all queued messages when connection becomes ready
   */
  flushMessageQueue() {
    if (!this.websocket || this.websocket.readyState !== 1) {
      return;
    }
    const queue = [...this.messageQueue];
    this.messageQueue = [];
    queue.forEach((queuedMessage) => {
      try {
        const messageObj = JSON.parse(queuedMessage.message);
        if (messageObj.type === "publish") {
          this.sendQueuedMessage(queuedMessage);
        } else {
          this.websocket.send(queuedMessage.message);
          clearTimeout(queuedMessage.timeout);
          queuedMessage.resolve("sent");
        }
      } catch (error) {
        clearTimeout(queuedMessage.timeout);
        queuedMessage.reject(new BlinkRealtimeError("Invalid queued message format"));
      }
    });
  }
  async connectWebSocket() {
    if (this.websocket && this.websocket.readyState === 1) {
      this.isConnected = true;
      return;
    }
    if (this.isConnecting) {
      return new Promise((resolve, reject) => {
        const checkConnection = () => {
          if (this.isConnected) {
            resolve();
          } else if (!this.isConnecting) {
            reject(new BlinkRealtimeError("Connection failed"));
          } else {
            setTimeout(checkConnection, 100);
          }
        };
        checkConnection();
      });
    }
    this.isConnecting = true;
    this.isConnected = false;
    return new Promise((resolve, reject) => {
      try {
        const httpClient = this.httpClient;
        const coreUrl = httpClient.coreUrl || "https://core.blink.new";
        const baseUrl = coreUrl.replace("https://", "wss://").replace("http://", "ws://");
        const wsUrl = `${baseUrl}?project_id=${this.projectId}`;
        console.log(`\u{1F517} Attempting WebSocket connection to: ${wsUrl}`);
        const WSClass = getWebSocketClass();
        this.websocket = new WSClass(wsUrl);
        if (!this.websocket) {
          this.isConnecting = false;
          reject(new BlinkRealtimeError("Failed to create WebSocket instance"));
          return;
        }
        this.websocket.onopen = () => {
          console.log(`\u{1F517} Connected to realtime for project ${this.projectId}`);
          this.isConnecting = false;
          this.isConnected = true;
          this.reconnectAttempts = 0;
          this.flushMessageQueue();
          resolve();
        };
        this.websocket.onmessage = (event) => {
          try {
            const message = JSON.parse(event.data);
            this.handleWebSocketMessage(message);
          } catch (error) {
            console.error("Failed to parse WebSocket message:", error);
          }
        };
        this.websocket.onclose = () => {
          console.log(`\u{1F50C} Disconnected from realtime for project ${this.projectId}`);
          this.isConnecting = false;
          this.isConnected = false;
          this.isSubscribed = false;
          this.rejectQueuedMessages(new BlinkRealtimeError("WebSocket connection closed"));
          if (this.pendingSubscription) {
            clearTimeout(this.pendingSubscription.timeout);
            this.pendingSubscription.reject(new BlinkRealtimeError("Connection closed during subscription"));
            this.pendingSubscription = null;
          }
          this.scheduleReconnect();
        };
        this.websocket.onerror = (error) => {
          console.error("WebSocket error:", error);
          console.error("WebSocket URL was:", wsUrl);
          console.error("WebSocket readyState:", this.websocket?.readyState);
          this.isConnecting = false;
          this.isConnected = false;
          reject(new BlinkRealtimeError(`WebSocket connection failed to ${wsUrl}`));
        };
        setTimeout(() => {
          if (this.websocket?.readyState !== 1) {
            this.isConnecting = false;
            reject(new BlinkRealtimeError("WebSocket connection timeout"));
          }
        }, 1e4);
      } catch (error) {
        this.isConnecting = false;
        reject(new BlinkRealtimeError(`Failed to create WebSocket connection: ${error instanceof Error ? error.message : "Unknown error"}`));
      }
    });
  }
  /**
   * Reject all queued messages with the given error
   */
  rejectQueuedMessages(error) {
    const queue = [...this.messageQueue];
    this.messageQueue = [];
    queue.forEach((queuedMessage) => {
      clearTimeout(queuedMessage.timeout);
      queuedMessage.reject(error);
    });
  }
  handleWebSocketMessage(message) {
    switch (message.type) {
      case "message":
        this.messageCallbacks.forEach((callback) => {
          try {
            callback(message.payload);
          } catch (error) {
            console.error("Error in message callback:", error);
          }
        });
        break;
      case "presence":
        this.presenceCallbacks.forEach((callback) => {
          try {
            const users = message.payload.data?.users || [];
            callback(users);
          } catch (error) {
            console.error("Error in presence callback:", error);
          }
        });
        break;
      case "subscribed":
        console.log(`\u2705 Subscribed to channel: ${message.payload.channel}`);
        if (this.pendingSubscription && message.payload.channel === this.channelName) {
          this.pendingSubscription.resolve();
        }
        break;
      case "unsubscribed":
        console.log(`\u274C Unsubscribed from channel: ${message.payload.channel}`);
        break;
      case "published":
        break;
      case "pong":
        break;
      case "error":
        console.error("Realtime error:", message.payload.error);
        if (this.pendingSubscription && message.payload.channel === this.channelName) {
          this.pendingSubscription.reject(new BlinkRealtimeError(`Subscription error: ${message.payload.error}`));
        }
        break;
      default:
        console.log("Unknown message type:", message.type);
    }
  }
  startHeartbeat() {
    if (this.heartbeatTimer) {
      clearInterval(this.heartbeatTimer);
    }
    this.heartbeatTimer = globalThis.setInterval(() => {
      if (this.websocket && this.websocket.readyState === 1) {
        this.websocket.send(JSON.stringify({ type: "ping", payload: {} }));
      }
    }, 25e3);
  }
  scheduleReconnect() {
    if (this.reconnectTimer) {
      clearTimeout(this.reconnectTimer);
    }
    if (!this.isSubscribed && !this.pendingSubscription) {
      return;
    }
    this.reconnectAttempts++;
    const baseDelay = Math.min(3e4, Math.pow(2, this.reconnectAttempts) * 1e3);
    const jitter = Math.random() * 1e3;
    const delay = baseDelay + jitter;
    console.log(`\u{1F504} Scheduling reconnect attempt ${this.reconnectAttempts} in ${Math.round(delay)}ms`);
    this.reconnectTimer = globalThis.setTimeout(async () => {
      if (this.isSubscribed || this.pendingSubscription) {
        try {
          await this.connectWebSocket();
          if (this.isSubscribed && this.websocket) {
            const subscribeMessage = {
              type: "subscribe",
              payload: {
                channel: this.channelName
              }
            };
            this.websocket.send(JSON.stringify(subscribeMessage));
            this.startHeartbeat();
          }
        } catch (error) {
          console.error("Reconnection failed:", error);
          this.scheduleReconnect();
        }
      }
    }, delay);
  }
  cleanup() {
    this.isSubscribed = false;
    this.isConnected = false;
    this.isConnecting = false;
    if (this.pendingSubscription) {
      clearTimeout(this.pendingSubscription.timeout);
      this.pendingSubscription.reject(new BlinkRealtimeError("Channel cleanup"));
      this.pendingSubscription = null;
    }
    this.rejectQueuedMessages(new BlinkRealtimeError("Channel cleanup"));
    if (this.heartbeatTimer) {
      clearInterval(this.heartbeatTimer);
      this.heartbeatTimer = null;
    }
    if (this.reconnectTimer) {
      clearTimeout(this.reconnectTimer);
      this.reconnectTimer = null;
    }
    if (this.websocket) {
      this.websocket.close();
      this.websocket = null;
    }
    this.messageCallbacks = [];
    this.presenceCallbacks = [];
  }
};
var BlinkRealtimeImpl = class {
  constructor(httpClient, projectId) {
    this.httpClient = httpClient;
    this.projectId = projectId;
  }
  channels = /* @__PURE__ */ new Map();
  handlers = {};
  channel(name) {
    if (!this.channels.has(name)) {
      this.channels.set(name, new BlinkRealtimeChannel(name, this.httpClient, this.projectId));
    }
    return this.channels.get(name);
  }
  async subscribe(channelName, callback, options = {}) {
    const channel = this.channel(channelName);
    await channel.subscribe(options);
    const state = this.handlers[channelName] ??= {
      msgHandlers: /* @__PURE__ */ new Set(),
      presHandlers: /* @__PURE__ */ new Set(),
      subscribed: true
    };
    state.msgHandlers.add(callback);
    const messageUnsub = channel.onMessage(callback);
    return () => {
      messageUnsub();
      state.msgHandlers.delete(callback);
      if (state.msgHandlers.size === 0 && state.presHandlers.size === 0) {
        channel.unsubscribe();
        delete this.handlers[channelName];
      }
    };
  }
  async publish(channelName, type, data, options = {}) {
    const channel = this.channel(channelName);
    return channel.publish(type, data, options);
  }
  async presence(channelName) {
    const channel = this.channel(channelName);
    return channel.getPresence();
  }
  onPresence(channelName, callback) {
    const channel = this.channel(channelName);
    const state = this.handlers[channelName] ??= {
      msgHandlers: /* @__PURE__ */ new Set(),
      presHandlers: /* @__PURE__ */ new Set(),
      subscribed: false
    };
    state.presHandlers.add(callback);
    const presenceUnsub = channel.onPresence(callback);
    return () => {
      presenceUnsub();
      state.presHandlers.delete(callback);
      if (state.msgHandlers.size === 0 && state.presHandlers.size === 0) {
        channel.unsubscribe();
        delete this.handlers[channelName];
      }
    };
  }
};

// src/notifications.ts
var BlinkNotificationsImpl = class {
  constructor(httpClient) {
    this.httpClient = httpClient;
  }
  /**
   * Sends an email using the Blink Notifications API.
   *
   * @param params - An object containing the details for the email.
   *   - `to`: The recipient's email address or an array of addresses.
   *   - `subject`: The subject line of the email.
   *   - `html`: The HTML body of the email. For best results across all email
   *             clients (like Gmail, Outlook), use inline CSS and table-based layouts.
   *   - `text`: A plain-text version of the email body (optional).
   *   - `from`: A custom sender name (e.g., "Acme Inc"). The email address will
   *             be auto-generated by the project (e.g., "noreply@project.blink-email.com").
   *   - `replyTo`: An email address for recipients to reply to (optional).
   *   - `cc`: A CC recipient's email address or an array of addresses (optional).
   *   - `bcc`: A BCC recipient's email address or an array of addresses (optional).
   *   - `attachments`: An array of objects for files to attach, each with a `url`.
   *                    The file at the URL will be fetched and attached by the server.
   *
   * @example
   * ```ts
   * // Send a simple email
   * const { success, messageId } = await blink.notifications.email({
   *   to: 'customer@example.com',
   *   subject: 'Your order has shipped!',
   *   html: '<h1>Order Confirmation</h1><p>Your order #12345 is on its way.</p>'
   * });
   *
   * // Send an email with attachments and a custom from name
   * const { success } = await blink.notifications.email({
   *   to: ['team@example.com', 'manager@example.com'],
   *   subject: 'New Invoice',
   *   from: 'Blink Invoicing',
   *   html: '<p>Please find the invoice attached.</p>',
   *   attachments: [
   *     { url: 'https://example.com/invoice.pdf', filename: 'invoice.pdf' }
   *   ]
   * });
   * ```
   *
   * @returns A promise that resolves with an object containing the status of the email send.
   *   - `success`: A boolean indicating if the email was sent successfully.
   *   - `messageId`: The unique ID of the message from the email provider.
   */
  async email(params) {
    try {
      if (!params.to || !params.subject || !params.html && !params.text) {
        throw new BlinkNotificationsError('The "to", "subject", and either "html" or "text" fields are required.');
      }
      const response = await this.httpClient.post(`/api/notifications/${this.httpClient.projectId}/email`, params);
      if (!response.data || typeof response.data.success !== "boolean") {
        throw new BlinkNotificationsError("Invalid response from email API");
      }
      return response.data;
    } catch (error) {
      if (error instanceof BlinkNotificationsError) {
        throw error;
      }
      const errorMessage = error.response?.data?.error?.message || error.message || "An unknown error occurred";
      throw new BlinkNotificationsError(`Failed to send email: ${errorMessage}`, error.response?.status, error.response?.data?.error);
    }
  }
};

// src/analytics.ts
var SESSION_DURATION = 30 * 60 * 1e3;
var MAX_BATCH_SIZE = 10;
var BATCH_TIMEOUT = 3e3;
var MAX_STRING_LENGTH = 256;
var STORAGE_KEY_QUEUE = "blinkAnalyticsQueue";
var STORAGE_KEY_SESSION = "blinkAnalyticsSession";
var STORAGE_KEY_ATTRIBUTION = "blinkAnalyticsAttribution";
var BlinkAnalyticsImpl = class {
  httpClient;
  projectId;
  queue = [];
  timer = null;
  enabled = true;
  userId = null;
  userEmail = null;
  hasTrackedPageview = false;
  utmParams = {};
  persistedAttribution = {};
  constructor(httpClient, projectId) {
    this.httpClient = httpClient;
    this.projectId = projectId;
    if (typeof window === "undefined") {
      return;
    }
    if (navigator.doNotTrack === "1") {
      this.enabled = false;
      return;
    }
    this.loadPersistedAttribution();
    this.captureUTMParams();
    this.loadQueue();
    this.trackPageview();
    this.setupRouteChangeListener();
    this.setupUnloadListener();
  }
  /**
   * Log a custom analytics event
   */
  log(eventName, data = {}) {
    if (!this.enabled || typeof window === "undefined") {
      return;
    }
    const event = this.buildEvent(eventName, data);
    this.enqueue(event);
  }
  /**
   * Disable analytics tracking
   */
  disable() {
    this.enabled = false;
    this.clearTimer();
  }
  /**
   * Cleanup analytics instance (remove from global tracking)
   */
  destroy() {
    this.disable();
    if (typeof window !== "undefined") {
      window.__blinkAnalyticsInstances?.delete(this);
    }
  }
  /**
   * Enable analytics tracking
   */
  enable() {
    this.enabled = true;
  }
  /**
   * Check if analytics is enabled
   */
  isEnabled() {
    return this.enabled;
  }
  /**
   * Set the user ID for analytics events
   */
  setUserId(userId) {
    this.userId = userId;
  }
  /**
   * Set the user email for analytics events
   */
  setUserEmail(email) {
    this.userEmail = email;
  }
  /**
   * Clear persisted attribution data
   */
  clearAttribution() {
    this.persistedAttribution = {};
    try {
      localStorage.removeItem(STORAGE_KEY_ATTRIBUTION);
    } catch {
    }
  }
  // Private methods
  buildEvent(type, data = {}) {
    const sessionId = this.getOrCreateSessionId();
    const channel = this.detectChannel();
    return {
      type,
      timestamp: (/* @__PURE__ */ new Date()).toISOString(),
      project_id: this.projectId,
      user_id: this.userId,
      user_email: this.userEmail,
      session_id: sessionId,
      pathname: window.location.pathname,
      referrer: document.referrer || null,
      screen_width: window.innerWidth,
      channel,
      utm_source: this.utmParams.utm_source || this.persistedAttribution.utm_source || null,
      utm_medium: this.utmParams.utm_medium || this.persistedAttribution.utm_medium || null,
      utm_campaign: this.utmParams.utm_campaign || this.persistedAttribution.utm_campaign || null,
      utm_content: this.utmParams.utm_content || this.persistedAttribution.utm_content || null,
      utm_term: this.utmParams.utm_term || this.persistedAttribution.utm_term || null,
      ...this.sanitizeData(data)
    };
  }
  sanitizeData(data) {
    if (typeof data === "string") {
      return data.length > MAX_STRING_LENGTH ? data.slice(0, MAX_STRING_LENGTH - 3) + "..." : data;
    }
    if (typeof data === "object" && data !== null) {
      const result = {};
      for (const key in data) {
        result[key] = this.sanitizeData(data[key]);
      }
      return result;
    }
    return data;
  }
  enqueue(event) {
    this.queue.push(event);
    this.persistQueue();
    if (this.queue.length >= MAX_BATCH_SIZE) {
      this.flush();
    } else if (!this.timer) {
      this.timer = setTimeout(() => this.flush(), BATCH_TIMEOUT);
    }
  }
  async flush() {
    this.clearTimer();
    if (this.queue.length === 0) {
      return;
    }
    const events = this.queue.slice(0, MAX_BATCH_SIZE);
    this.queue = this.queue.slice(MAX_BATCH_SIZE);
    this.persistQueue();
    try {
      await this.httpClient.post(`/api/analytics/${this.projectId}/log`, { events });
    } catch (error) {
      this.queue = [...events, ...this.queue];
      this.persistQueue();
      console.error("Failed to send analytics events:", error);
    }
    if (this.queue.length > 0) {
      this.timer = setTimeout(() => this.flush(), BATCH_TIMEOUT);
    }
  }
  clearTimer() {
    if (this.timer) {
      clearTimeout(this.timer);
      this.timer = null;
    }
  }
  getOrCreateSessionId() {
    try {
      const stored = localStorage.getItem(STORAGE_KEY_SESSION);
      if (stored) {
        const session = JSON.parse(stored);
        const now = Date.now();
        if (now - session.lastActivityAt > SESSION_DURATION) {
          return this.createNewSession();
        }
        session.lastActivityAt = now;
        localStorage.setItem(STORAGE_KEY_SESSION, JSON.stringify(session));
        return session.id;
      }
      return this.createNewSession();
    } catch {
      return null;
    }
  }
  createNewSession() {
    const now = Date.now();
    const randomId = Math.random().toString(36).substring(2, 10);
    const session = {
      id: `sess_${now}_${randomId}`,
      startedAt: now,
      lastActivityAt: now
    };
    try {
      localStorage.setItem(STORAGE_KEY_SESSION, JSON.stringify(session));
    } catch {
    }
    return session.id;
  }
  loadQueue() {
    try {
      const stored = localStorage.getItem(STORAGE_KEY_QUEUE);
      if (stored) {
        this.queue = JSON.parse(stored);
        if (this.queue.length > 0) {
          this.timer = setTimeout(() => this.flush(), BATCH_TIMEOUT);
        }
      }
    } catch {
      this.queue = [];
    }
  }
  persistQueue() {
    try {
      if (this.queue.length === 0) {
        localStorage.removeItem(STORAGE_KEY_QUEUE);
      } else {
        localStorage.setItem(STORAGE_KEY_QUEUE, JSON.stringify(this.queue));
      }
    } catch {
    }
  }
  trackPageview() {
    if (!this.hasTrackedPageview) {
      this.log("pageview");
      this.hasTrackedPageview = true;
    }
  }
  setupRouteChangeListener() {
    if (!window.__blinkAnalyticsSetup) {
      const originalPushState = history.pushState;
      const originalReplaceState = history.replaceState;
      const analyticsInstances = /* @__PURE__ */ new Set();
      window.__blinkAnalyticsInstances = analyticsInstances;
      history.pushState = (...args) => {
        originalPushState.apply(history, args);
        analyticsInstances.forEach((instance) => {
          if (instance.isEnabled()) {
            instance.log("pageview");
          }
        });
      };
      history.replaceState = (...args) => {
        originalReplaceState.apply(history, args);
        analyticsInstances.forEach((instance) => {
          if (instance.isEnabled()) {
            instance.log("pageview");
          }
        });
      };
      window.addEventListener("popstate", () => {
        analyticsInstances.forEach((instance) => {
          if (instance.isEnabled()) {
            instance.log("pageview");
          }
        });
      });
      window.__blinkAnalyticsSetup = true;
    }
    window.__blinkAnalyticsInstances?.add(this);
  }
  setupUnloadListener() {
    window.addEventListener("pagehide", () => {
      this.flush();
    });
    window.addEventListener("unload", () => {
      this.flush();
    });
  }
  captureUTMParams() {
    const urlParams = new URLSearchParams(window.location.search);
    this.utmParams = {
      utm_source: urlParams.get("utm_source"),
      utm_medium: urlParams.get("utm_medium"),
      utm_campaign: urlParams.get("utm_campaign"),
      utm_content: urlParams.get("utm_content"),
      utm_term: urlParams.get("utm_term")
    };
    const hasNewParams = Object.values(this.utmParams).some((v) => v !== null);
    if (hasNewParams) {
      this.persistAttribution();
    }
  }
  loadPersistedAttribution() {
    try {
      const stored = localStorage.getItem(STORAGE_KEY_ATTRIBUTION);
      if (stored) {
        this.persistedAttribution = JSON.parse(stored);
      }
    } catch {
      this.persistedAttribution = {};
    }
  }
  persistAttribution() {
    try {
      const attribution = {
        ...this.persistedAttribution,
        ...Object.fromEntries(
          Object.entries(this.utmParams).filter(([_, v]) => v !== null)
        )
      };
      localStorage.setItem(STORAGE_KEY_ATTRIBUTION, JSON.stringify(attribution));
      this.persistedAttribution = attribution;
    } catch {
    }
  }
  detectChannel() {
    const referrer = document.referrer;
    const utmMedium = this.utmParams.utm_medium;
    this.utmParams.utm_source;
    if (utmMedium) {
      if (utmMedium === "cpc" || utmMedium === "ppc") return "Paid Search";
      if (utmMedium === "email") return "Email";
      if (utmMedium === "social") return "Social";
      if (utmMedium === "referral") return "Referral";
      if (utmMedium === "display") return "Display";
      if (utmMedium === "affiliate") return "Affiliate";
    }
    if (!referrer) return "Direct";
    try {
      const referrerUrl = new URL(referrer);
      const referrerDomain = referrerUrl.hostname.toLowerCase();
      if (/google\.|bing\.|yahoo\.|duckduckgo\.|baidu\.|yandex\./.test(referrerDomain)) {
        return "Organic Search";
      }
      if (/facebook\.|twitter\.|linkedin\.|instagram\.|youtube\.|tiktok\.|reddit\./.test(referrerDomain)) {
        return "Social";
      }
      if (/mail\.|outlook\.|gmail\./.test(referrerDomain)) {
        return "Email";
      }
      return "Referral";
    } catch {
      return "Direct";
    }
  }
};

// src/client.ts
var BlinkClientImpl = class {
  auth;
  db;
  storage;
  ai;
  data;
  realtime;
  notifications;
  analytics;
  httpClient;
  constructor(config) {
    this.auth = new BlinkAuth(config);
    this.httpClient = new HttpClient(
      config,
      () => this.auth.getToken(),
      () => this.auth.getValidToken()
    );
    this.db = new BlinkDatabase(this.httpClient);
    this.storage = new BlinkStorageImpl(this.httpClient);
    this.ai = new BlinkAIImpl(this.httpClient);
    this.data = new BlinkDataImpl(this.httpClient, config.projectId);
    this.realtime = new BlinkRealtimeImpl(this.httpClient, config.projectId);
    this.notifications = new BlinkNotificationsImpl(this.httpClient);
    this.analytics = new BlinkAnalyticsImpl(this.httpClient, config.projectId);
    this.auth.onAuthStateChanged((state) => {
      if (state.isAuthenticated && state.user) {
        this.analytics.setUserId(state.user.id);
        this.analytics.setUserEmail(state.user.email);
      } else {
        this.analytics.setUserId(null);
        this.analytics.setUserEmail(null);
      }
    });
  }
};
function createClient(config) {
  if (!config.projectId) {
    throw new Error("projectId is required");
  }
  const clientConfig = {
    authRequired: true,
    ...config
  };
  return new BlinkClientImpl(clientConfig);
}

exports.BlinkAIImpl = BlinkAIImpl;
exports.BlinkAnalyticsImpl = BlinkAnalyticsImpl;
exports.BlinkDataImpl = BlinkDataImpl;
exports.BlinkDatabase = BlinkDatabase;
exports.BlinkRealtimeChannel = BlinkRealtimeChannel;
exports.BlinkRealtimeImpl = BlinkRealtimeImpl;
exports.BlinkStorageImpl = BlinkStorageImpl;
exports.BlinkTable = BlinkTable;
exports.createClient = createClient;
//# sourceMappingURL=index.js.map
//# sourceMappingURL=index.js.map